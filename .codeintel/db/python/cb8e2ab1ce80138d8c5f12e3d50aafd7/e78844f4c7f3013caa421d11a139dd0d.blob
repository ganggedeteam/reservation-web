<scope doc="Package resource API --------------------" ilk="blob" lang="Python" name="__init__" src="D:\Program Files (x86)\Python\lib\site-packages\pkg_resources\__init__.py"><import line="18" module="__future__" symbol="absolute_import" /><import line="20" module="sys" /><import line="21" module="os" /><import line="22" module="io" /><import line="23" module="time" /><import line="24" module="re" /><import line="25" module="types" /><import line="26" module="zipfile" /><import line="27" module="zipimport" /><import line="28" module="warnings" /><import line="29" module="stat" /><import line="30" module="functools" /><import line="31" module="pkgutil" /><import line="32" module="operator" /><import line="33" module="platform" /><import line="34" module="collections" /><import line="35" module="plistlib" /><import line="36" module="email.parser" /><import line="37" module="errno" /><import line="38" module="tempfile" /><import line="39" module="textwrap" /><import line="40" module="itertools" /><import line="41" module="inspect" /><import line="42" module="pkgutil" symbol="get_importer" /><import line="45" module="_imp" /><import alias="_imp" line="48" module="imp" /><import line="50" module="pkg_resources.extern" symbol="six" /><import line="51" module="pkg_resources.extern.six.moves" symbol="urllib" /><import line="51" module="pkg_resources.extern.six.moves" symbol="map" /><import line="51" module="pkg_resources.extern.six.moves" symbol="filter" /><import line="54" module="os" symbol="utime" /><import line="56" module="os" symbol="mkdir" /><import line="56" module="os" symbol="rename" /><import line="56" module="os" symbol="unlink" /><import alias="os_open" line="62" module="os" symbol="open" /><import line="63" module="os.path" symbol="isdir" /><import line="63" module="os.path" symbol="split" /><import alias="importlib_machinery" line="66" module="importlib.machinery" /><import line="72" module="." symbol="py31compat" /><import line="73" module="pkg_resources.extern" symbol="appdirs" /><import line="74" module="pkg_resources.extern" symbol="packaging" /><variable citdl="False" line="57" name="WRITE_SUPPORT" /><variable line="70" name="importlib_machinery" /><variable line="86" name="PermissionError" /><variable line="87" name="NotADirectoryError" /><variable line="91" name="require" /><variable line="92" name="working_set" /><scope classrefs="RuntimeWarning" doc="Used when there is an issue with a version or specifier not complying with&#10;PEP 440." ilk="class" line="95" lineend="99" name="PEP440Warning" /><scope attributes="protected" classrefs="object" ilk="class" line="102" lineend="197" name="_SetuptoolsVersionMixin"><scope ilk="function" line="103" lineend="104" name="__hash__" signature="__hash__()"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="103" name="self" /></scope><scope ilk="function" line="106" lineend="110" name="__lt__" returns="bool" signature="__lt__(other)"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="106" name="self" /><variable ilk="argument" line="106" name="other" /></scope><scope ilk="function" line="112" lineend="116" name="__le__" returns="bool" signature="__le__(other)"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="112" name="self" /><variable ilk="argument" line="112" name="other" /></scope><scope ilk="function" line="118" lineend="122" name="__eq__" returns="bool" signature="__eq__(other)"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="118" name="self" /><variable ilk="argument" line="118" name="other" /></scope><scope ilk="function" line="124" lineend="128" name="__ge__" returns="bool" signature="__ge__(other)"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="124" name="self" /><variable ilk="argument" line="124" name="other" /></scope><scope ilk="function" line="130" lineend="134" name="__gt__" returns="bool" signature="__gt__(other)"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="130" name="self" /><variable ilk="argument" line="130" name="other" /></scope><scope ilk="function" line="136" lineend="140" name="__ne__" returns="bool" signature="__ne__(other)"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="136" name="self" /><variable ilk="argument" line="136" name="other" /></scope><scope ilk="function" line="142" lineend="143" name="__getitem__" signature="__getitem__(key)"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="142" name="self" /><variable ilk="argument" line="142" name="key" /></scope><scope ilk="function" line="145" lineend="197" name="__iter__" signature="__iter__()"><variable citdl="_SetuptoolsVersionMixin" ilk="argument" line="145" name="self" /><variable citdl="re.compile()" line="146" name="component_re" /><variable citdl="{}.get" line="147" name="replace" /><scope attributes="protected" ilk="function" line="155" lineend="167" name="_parse_version_parts" signature="_parse_version_parts(s)"><variable ilk="argument" line="155" name="s" /><variable citdl="replace()" line="156" name="part" /></scope><scope ilk="function" line="169" lineend="181" name="old_parse_version" returns="tuple()" signature="old_parse_version(s)"><variable ilk="argument" line="169" name="s" /><variable citdl="list" line="170" name="parts" /><variable line="171" name="part" /></scope><variable line="196" name="part" /></scope></scope><scope classrefs="_SetuptoolsVersionMixin packaging.version.Version" ilk="class" line="200" lineend="201" name="SetuptoolsVersion" /><scope classrefs="_SetuptoolsVersionMixin packaging.version.LegacyVersion" ilk="class" line="204" lineend="206" name="SetuptoolsLegacyVersion" /><scope ilk="function" line="209" lineend="213" name="parse_version" returns="SetuptoolsVersion" signature="parse_version(v)"><variable ilk="argument" line="209" name="v" /></scope><variable attributes="protected" citdl="dict" line="216" name="_state_vars" /><scope attributes="protected" ilk="function" line="219" lineend="221" name="_declare_state" signature="_declare_state(**vartype)"><variable attributes="kwargs" ilk="argument" line="219" name="vartype" /></scope><scope ilk="function" line="224" lineend="229" name="__getstate__" returns="dict" signature="__getstate__()"><variable citdl="dict" line="225" name="state" /><variable citdl="globals()" line="226" name="g" /><variable line="227" name="v" /><variable line="227" name="k" /></scope><scope ilk="function" line="232" lineend="236" name="__setstate__" signature="__setstate__(state)"><variable ilk="argument" line="232" name="state" /><variable citdl="globals()" line="233" name="g" /><variable line="234" name="k" /><variable line="234" name="v" /></scope><scope attributes="protected" ilk="function" line="239" lineend="240" name="_sget_dict" returns="val.copy()" signature="_sget_dict(val)"><variable ilk="argument" line="239" name="val" /></scope><scope attributes="protected" ilk="function" line="243" lineend="245" name="_sset_dict" signature="_sset_dict(key, ob, state)"><variable ilk="argument" line="243" name="key" /><variable ilk="argument" line="243" name="ob" /><variable ilk="argument" line="243" name="state" /></scope><scope attributes="protected" ilk="function" line="248" lineend="249" name="_sget_object" returns="val.__getstate__()" signature="_sget_object(val)"><variable ilk="argument" line="248" name="val" /></scope><scope attributes="protected" ilk="function" line="252" lineend="253" name="_sset_object" signature="_sset_object(key, ob, state)"><variable ilk="argument" line="252" name="key" /><variable ilk="argument" line="252" name="ob" /><variable ilk="argument" line="252" name="state" /></scope><variable attributes="protected" line="256" name="_sget_none" /><scope doc="Return this platform's maximum compatible version.&#10;&#10;distutils.util.get_platform() normally reports the minimum version&#10;of Mac OS X that would be required to *use* extensions produced by&#10;distutils.  But what we want when checking compatibility is to know the&#10;version of Mac OS X that we are *running*.  To allow usage of packages that&#10;explicitly require a newer version of Mac OS X, we must also know the&#10;current version of the OS.&#10;&#10;If this condition occurs for any other platform with a version in its&#10;platform strings, this function should be extended accordingly." ilk="function" line="259" lineend="280" name="get_supported_platform" returns="get_build_platform()" signature="get_supported_platform()"><variable citdl="get_build_platform()" line="272" name="plat" /><variable citdl="macosVersionString.match()" line="273" name="m" /></scope><variable citdl="list" line="283" name="__all__" /><scope classrefs="Exception" doc="Abstract base for dependency resolution errors" ilk="class" line="330" lineend="334" name="ResolutionError"><scope ilk="function" line="333" lineend="334" name="__repr__" signature="__repr__()"><variable citdl="ResolutionError" ilk="argument" line="333" name="self" /></scope></scope><scope classrefs="ResolutionError" doc="An already-installed version conflicts with the requested version.&#10;&#10;Should be initialized with the installed Distribution and the requested&#10;Requirement." ilk="class" line="337" lineend="366" name="VersionConflict"><variable attributes="protected" citdl="str" line="345" name="_template" /><scope attributes="__hidden__" ilk="function" line="347" lineend="347" name="dist (property getter)" signature="dist (property getter)()"><variable citdl="VersionConflict" ilk="argument" line="347" name="self" /></scope><variable attributes="property" line="347" name="dist" /><variable attributes="property" line="351" name="req" /><scope attributes="__hidden__" ilk="function" line="351" lineend="351" name="req (property getter)" signature="req (property getter)()"><variable citdl="VersionConflict" ilk="argument" line="351" name="self" /></scope><scope ilk="function" line="355" lineend="356" name="report" returns="self._template.format()" signature="report()"><variable citdl="VersionConflict" ilk="argument" line="355" name="self" /></scope><scope doc="If required_by is non-empty, return a version of self that is a&#10;ContextualVersionConflict." ilk="function" line="358" lineend="366" name="with_context" returns="VersionConflict" signature="with_context(required_by)"><variable citdl="VersionConflict" ilk="argument" line="358" name="self" /><variable ilk="argument" line="358" name="required_by" /><variable line="365" name="args" /></scope></scope><scope classrefs="VersionConflict" doc="A VersionConflict that accepts a third parameter, the set of the&#10;requirements that required the installed Distribution." ilk="class" line="369" lineend="377" name="ContextualVersionConflict"><variable attributes="protected" line="375" name="_template" /><variable attributes="property" line="377" name="required_by" /><scope attributes="__hidden__" ilk="function" line="377" lineend="377" name="required_by (property getter)" signature="required_by (property getter)()"><variable citdl="ContextualVersionConflict" ilk="argument" line="377" name="self" /></scope></scope><scope classrefs="ResolutionError" doc="A requested distribution was not found" ilk="class" line="382" lineend="406" name="DistributionNotFound"><variable attributes="protected" citdl="str" line="385" name="_template" /><variable attributes="property" line="388" name="req" /><scope attributes="__hidden__" ilk="function" line="388" lineend="388" name="req (property getter)" signature="req (property getter)()"><variable citdl="DistributionNotFound" ilk="argument" line="388" name="self" /></scope><scope attributes="__hidden__" ilk="function" line="392" lineend="392" name="requirers (property getter)" signature="requirers (property getter)()"><variable citdl="DistributionNotFound" ilk="argument" line="392" name="self" /></scope><variable attributes="property" line="392" name="requirers" /><variable attributes="property" citdl="__builtins__.str.join()" line="396" name="requirers_str" /><scope attributes="__hidden__" ilk="function" line="396" lineend="396" name="requirers_str (property getter)" returns="str" signature="requirers_str (property getter)()"><variable citdl="DistributionNotFound" ilk="argument" line="396" name="self" /></scope><scope ilk="function" line="402" lineend="403" name="report" returns="self._template.format()" signature="report()"><variable citdl="DistributionNotFound" ilk="argument" line="402" name="self" /></scope><scope ilk="function" line="405" lineend="406" name="__str__" returns="DistributionNotFound.report()" signature="__str__()"><variable citdl="DistributionNotFound" ilk="argument" line="405" name="self" /></scope></scope><scope classrefs="ResolutionError" doc="Distribution doesn't have an &quot;extra feature&quot; of the given name" ilk="class" line="409" lineend="410" name="UnknownExtra" /><variable attributes="protected" citdl="dict" line="413" name="_provider_factories" /><variable line="415" name="PY_MAJOR" /><variable citdl="int" line="416" name="EGG_DIST" /><variable citdl="int" line="417" name="BINARY_DIST" /><variable citdl="int" line="418" name="SOURCE_DIST" /><variable citdl="int" line="419" name="CHECKOUT_DIST" /><variable citdl="int" line="420" name="DEVELOP_DIST" /><scope doc="Register `provider_factory` to make providers for `loader_type`&#10;&#10;`loader_type` is the type or class of a PEP 302 ``module.__loader__``,&#10;and `provider_factory` is a function that, passed a *module* object,&#10;returns an ``IResourceProvider`` for that module." ilk="function" line="423" lineend="430" name="register_loader_type" signature="register_loader_type(loader_type, provider_factory)"><variable ilk="argument" line="423" name="loader_type" /><variable ilk="argument" line="423" name="provider_factory" /></scope><scope doc="Return an IResourceProvider for the named module or requirement" ilk="function" line="433" lineend="443" name="get_provider" returns="_find_adapter()()" signature="get_provider(moduleOrReq)"><variable ilk="argument" line="433" name="moduleOrReq" /><variable line="438" name="module" /><variable citdl="getattr()" line="442" name="loader" /></scope><scope attributes="protected" ilk="function" line="446" lineend="459" name="_macosx_vers" signature="_macosx_vers(_cache=[])"><variable citdl="list" ilk="argument" line="446" name="_cache" /><variable line="448" name="version" /><variable citdl="str" line="451" name="plist" /><variable citdl="plistlib.readPlist()" line="454" name="plist_content" /></scope><scope attributes="protected" ilk="function" line="462" lineend="463" name="_macosx_arch" returns="{}.get()" signature="_macosx_arch(machine)"><variable ilk="argument" line="462" name="machine" /></scope><scope doc="Return this platform's string for platform-specific distributions&#10;&#10;XXX Currently this is the same as ``distutils.util.get_platform()``, but it&#10;needs some hacks for Linux and Mac OS X." ilk="function" line="466" lineend="491" name="get_build_platform" returns="get_platform()" signature="get_build_platform()"><import line="474" module="sysconfig" symbol="get_platform" /><import line="476" module="distutils.util" symbol="get_platform" /><variable citdl="get_platform()" line="478" name="plat" /><variable citdl="_macosx_vers()" line="481" name="version" /><variable line="482" name="machine" /></scope><variable citdl="re.compile()" line="494" name="macosVersionString" /><variable citdl="re.compile()" line="495" name="darwinVersionString" /><variable citdl="get_build_platform" line="497" name="get_platform" /><scope doc="Can code for the `provided` platform run on the `required` platform?&#10;&#10;Returns true if either platform is ``None``, or the platforms are equal.&#10;&#10;XXX Needs compatibility checks for Linux and other unixy OSes." ilk="function" line="500" lineend="543" name="compatible_platforms" returns="bool" signature="compatible_platforms(provided, required)"><variable ilk="argument" line="500" name="provided" /><variable ilk="argument" line="500" name="required" /><variable citdl="macosVersionString.match()" line="512" name="reqMac" /><variable citdl="macosVersionString.match()" line="514" name="provMac" /><variable citdl="darwinVersionString.match()" line="521" name="provDarwin" /><variable citdl="int()" line="523" name="dversion" /><variable line="524" name="macosversion" /></scope><scope doc="Locate distribution `dist_spec` and run its `script_name` script" ilk="function" line="546" lineend="552" name="run_script" signature="run_script(dist_spec, script_name)"><variable ilk="argument" line="546" name="dist_spec" /><variable ilk="argument" line="546" name="script_name" /><variable line="548" name="ns" /><variable line="549" name="name" /></scope><variable citdl="run_script" line="556" name="run_main" /><scope doc="Return a current distribution object for a Requirement or string" ilk="function" line="559" lineend="567" name="get_distribution" returns="get_provider()" signature="get_distribution(dist)"><variable citdl="Requirement.parse()" ilk="argument" line="559" name="dist" /></scope><scope doc="Return `name` entry point of `group` for `dist` or raise ImportError" ilk="function" line="570" lineend="572" name="load_entry_point" signature="load_entry_point(dist, group, name)"><variable ilk="argument" line="570" name="dist" /><variable ilk="argument" line="570" name="group" /><variable ilk="argument" line="570" name="name" /></scope><scope doc="Return the entry point map for `group`, or the full entry map" ilk="function" line="575" lineend="577" name="get_entry_map" signature="get_entry_map(dist, group=None)"><variable ilk="argument" line="575" name="dist" /><variable ilk="argument" line="575" name="group" /></scope><scope doc="Return the EntryPoint object for `group`+`name`, or ``None``" ilk="function" line="580" lineend="582" name="get_entry_info" signature="get_entry_info(dist, group, name)"><variable ilk="argument" line="580" name="dist" /><variable ilk="argument" line="580" name="group" /><variable ilk="argument" line="580" name="name" /></scope><scope ilk="class" line="585" lineend="605" name="IMetadataProvider"><scope doc="Does the package's distribution contain the named metadata?" ilk="function" line="586" lineend="587" name="has_metadata" signature="has_metadata()"><variable citdl="IMetadataProvider" ilk="argument" line="586" name="name" /></scope><scope doc="The named metadata resource as a string" ilk="function" line="589" lineend="590" name="get_metadata" signature="get_metadata()"><variable citdl="IMetadataProvider" ilk="argument" line="589" name="name" /></scope><scope doc="Yield named metadata resource as list of non-blank non-comment lines&#10;&#10;Leading and trailing whitespace is stripped from each line, and lines&#10;with ``#`` as the first non-blank character are omitted." ilk="function" line="592" lineend="596" name="get_metadata_lines" signature="get_metadata_lines()"><variable citdl="IMetadataProvider" ilk="argument" line="592" name="name" /></scope><scope doc="Is the named metadata a directory?  (like ``os.path.isdir()``)" ilk="function" line="598" lineend="599" name="metadata_isdir" signature="metadata_isdir()"><variable citdl="IMetadataProvider" ilk="argument" line="598" name="name" /></scope><scope doc="List of metadata names in the directory (like ``os.listdir()``)" ilk="function" line="601" lineend="602" name="metadata_listdir" signature="metadata_listdir()"><variable citdl="IMetadataProvider" ilk="argument" line="601" name="name" /></scope><scope doc="Execute the named script in the supplied namespace dictionary" ilk="function" line="604" lineend="605" name="run_script" signature="run_script(namespace)"><variable citdl="IMetadataProvider" ilk="argument" line="604" name="script_name" /><variable ilk="argument" line="604" name="namespace" /></scope></scope><scope classrefs="IMetadataProvider" doc="An object that provides access to package resources" ilk="class" line="608" lineend="633" name="IResourceProvider"><scope doc="Return a true filesystem path for `resource_name`&#10;&#10;`manager` must be an ``IResourceManager``" ilk="function" line="611" lineend="614" name="get_resource_filename" signature="get_resource_filename(resource_name)"><variable citdl="IResourceProvider" ilk="argument" line="611" name="manager" /><variable ilk="argument" line="611" name="resource_name" /></scope><scope doc="Return a readable file-like object for `resource_name`&#10;&#10;`manager` must be an ``IResourceManager``" ilk="function" line="616" lineend="619" name="get_resource_stream" signature="get_resource_stream(resource_name)"><variable citdl="IResourceProvider" ilk="argument" line="616" name="manager" /><variable ilk="argument" line="616" name="resource_name" /></scope><scope doc="Return a string containing the contents of `resource_name`&#10;&#10;`manager` must be an ``IResourceManager``" ilk="function" line="621" lineend="624" name="get_resource_string" signature="get_resource_string(resource_name)"><variable citdl="IResourceProvider" ilk="argument" line="621" name="manager" /><variable ilk="argument" line="621" name="resource_name" /></scope><scope doc="Does the package contain the named resource?" ilk="function" line="626" lineend="627" name="has_resource" signature="has_resource()"><variable citdl="IResourceProvider" ilk="argument" line="626" name="resource_name" /></scope><scope doc="Is the named resource a directory?  (like ``os.path.isdir()``)" ilk="function" line="629" lineend="630" name="resource_isdir" signature="resource_isdir()"><variable citdl="IResourceProvider" ilk="argument" line="629" name="resource_name" /></scope><scope doc="List of resource names in the directory (like ``os.listdir()``)" ilk="function" line="632" lineend="633" name="resource_listdir" signature="resource_listdir()"><variable citdl="IResourceProvider" ilk="argument" line="632" name="resource_name" /></scope></scope><scope classrefs="object" doc="A collection of active distributions on sys.path (or a similar list)" ilk="class" line="636" lineend="1020" name="WorkingSet"><scope attributes="__ctor__" doc="Create working set from list of path entries (default=sys.path)" ilk="function" line="639" lineend="650" name="__init__" signature="WorkingSet(entries=None)"><variable citdl="WorkingSet" ilk="argument" line="639" name="self" /><variable citdl="sys.path" ilk="argument" line="639" name="entries" /><variable line="649" name="entry" /></scope><variable attributes="__instancevar__" citdl="list" line="641" name="entries" /><variable attributes="__instancevar__" citdl="keys.copy()" line="642" name="entry_keys" /><variable attributes="__instancevar__" citdl="dict" line="643" name="by_key" /><variable attributes="__instancevar__" citdl="list" line="644" name="callbacks" /><scope attributes="protected __classmethod__" doc="Prepare the master working set." ilk="function" line="652" lineend="652" name="_build_master" returns="cls()" signature="_build_master() - classmethod"><import line="659" module="__main__" symbol="__requires__" /><variable citdl="WorkingSet" ilk="argument" line="652" name="cls" /><variable citdl="cls()" line="657" name="ws" /></scope><scope attributes="protected __classmethod__" doc="Build a working set from a requirement spec. Rewrites sys.path." ilk="function" line="672" lineend="672" name="_build_from_requirements" returns="cls()" signature="_build_from_requirements(req_spec) - classmethod"><variable citdl="WorkingSet" ilk="argument" line="672" name="cls" /><variable ilk="argument" line="672" name="req_spec" /><variable citdl="cls()" line="679" name="ws" /><variable citdl="parse_requirements()" line="680" name="reqs" /><variable citdl="ws.resolve()" line="681" name="dists" /><variable line="682" name="dist" /><variable line="686" name="entry" /></scope><scope doc="Add a path item to ``.entries``, finding any distributions on it&#10;&#10;``find_distributions(entry, True)`` is used to find distributions&#10;corresponding to the path entry, and they are added.  `entry` is&#10;always appended to ``.entries``, even if it is already present.&#10;(This is because ``sys.path`` can contain the same value more than&#10;once, and the ``.entries`` of the ``sys.path`` WorkingSet should always&#10;equal ``sys.path``.)" ilk="function" line="694" lineend="707" name="add_entry" signature="add_entry(entry)"><variable citdl="WorkingSet" ilk="argument" line="694" name="self" /><variable ilk="argument" line="694" name="entry" /><variable line="706" name="dist" /></scope><scope doc="True if `dist` is the active distribution for its project" ilk="function" line="709" lineend="711" name="__contains__" returns="bool" signature="__contains__(dist)"><variable citdl="WorkingSet" ilk="argument" line="709" name="self" /><variable ilk="argument" line="709" name="dist" /></scope><scope doc="Find a distribution matching requirement `req`&#10;&#10;If there is an active distribution for the requested project, this&#10;returns it as int as it meets the version requirement specified by&#10;`req`.  But, if there is an active distribution for the project and it&#10;does *not* meet the `req` requirement, ``VersionConflict`` is raised.&#10;If there is no active distribution for the requested project, ``None``&#10;is returned." ilk="function" line="713" lineend="727" name="find" returns="self.by_key.get()" signature="find(req)"><variable citdl="WorkingSet" ilk="argument" line="713" name="self" /><variable ilk="argument" line="713" name="req" /><variable citdl="self.by_key.get()" line="723" name="dist" /></scope><scope doc="Yield entry point objects from `group` matching `name`&#10;&#10;If `name` is None, yields all entry points in `group` from all&#10;distributions in the working set, otherwise only ones matching&#10;both `group` and `name` are yielded (in distribution order)." ilk="function" line="729" lineend="742" name="iter_entry_points" signature="iter_entry_points(group, name=None)"><variable citdl="WorkingSet" ilk="argument" line="729" name="self" /><variable ilk="argument" line="729" name="group" /><variable ilk="argument" line="729" name="name" /><variable line="736" name="dist" /><variable citdl="dist.get_entry_map()" line="737" name="entries" /><variable line="739" name="ep" /></scope><scope doc="Locate distribution for `requires` and run `script_name` script" ilk="function" line="744" lineend="750" name="run_script" signature="run_script(requires, script_name)"><variable citdl="WorkingSet" ilk="argument" line="744" name="self" /><variable ilk="argument" line="744" name="requires" /><variable ilk="argument" line="744" name="script_name" /><variable line="746" name="ns" /><variable line="747" name="name" /></scope><scope doc="Yield distributions for non-duplicate projects in the working set&#10;&#10;The yield order is the order in which the items' path entries were&#10;added to the working set." ilk="function" line="752" lineend="767" name="__iter__" signature="__iter__()"><variable citdl="WorkingSet" ilk="argument" line="752" name="self" /><variable citdl="dict" line="758" name="seen" /><variable line="759" name="item" /><variable line="764" name="key" /></scope><scope doc="Add `dist` to working set, associated with `entry`&#10;&#10;If `entry` is unspecified, it defaults to the ``.location`` of `dist`.&#10;On exit from this routine, `entry` is added to the end of the working&#10;set's ``.entries`` (if it wasn't already present).&#10;&#10;`dist` is only added to the working set if it's for a project that&#10;doesn't already have a distribution in the set, unless `replace=True`.&#10;If it's added, any callbacks registered with the ``subscribe()`` method&#10;will be called." ilk="function" line="769" lineend="797" name="add" signature="add(dist, entry=None, insert=True, replace=False)"><variable citdl="WorkingSet" ilk="argument" line="769" name="self" /><variable ilk="argument" line="769" name="dist" /><variable citdl="dist.location" ilk="argument" line="769" name="entry" /><variable citdl="True" ilk="argument" line="769" name="insert" /><variable citdl="False" ilk="argument" line="769" name="replace" /><variable citdl="self.entry_keys.setdefault()" line="786" name="keys" /><variable citdl="self.entry_keys.setdefault()" line="787" name="keys2" /></scope><scope doc="List all distributions needed to (recursively) meet `requirements`&#10;&#10;`requirements` must be a sequence of ``Requirement`` objects.  `env`,&#10;if supplied, should be an ``Environment`` instance.  If&#10;not supplied, it defaults to all distributions available within any&#10;entry or distribution in the working set.  `installer`, if supplied,&#10;will be invoked with each requirement that cannot be met by an&#10;already-installed distribution; it should return a ``Distribution`` or&#10;``None``.&#10;&#10;Unless `replace_conflicting=True`, raises a VersionConflict exception&#10;if&#10;any requirements are found on the path that have the correct name but&#10;the wrong version.  Otherwise, if an `installer` is supplied it will be&#10;invoked to obtain the correct version of the requirement and activate&#10;it.&#10;&#10;`extras` is a list of the extras to be used with these requirements.&#10;This is important because extra requirements may look like `my_req;&#10;extra = &quot;my_extra&quot;`, which would otherwise be interpreted as a purely&#10;optional requirement.  Instead, we want to be able to assert that these&#10;requirements are truly required." ilk="function" line="799" lineend="889" name="resolve" returns="list" signature="resolve(requirements, env=None, installer=None, replace_conflicting=False, extras=None)"><variable citdl="WorkingSet" ilk="argument" line="799" name="self" /><variable ilk="argument" line="799" name="requirements" /><variable citdl="Environment()" ilk="argument" line="799" name="env" /><variable ilk="argument" line="799" name="installer" /><variable citdl="False" ilk="argument" line="799" name="replace_conflicting" /><variable ilk="argument" line="799" name="extras" /><variable citdl="dict" line="828" name="processed" /><variable citdl="dict" line="830" name="best" /><variable citdl="list" line="831" name="to_activate" /><variable citdl="_ReqExtras()" line="833" name="req_extras" /><variable citdl="collections.defaultdict()" line="837" name="required_by" /><variable citdl="requirements.pop()" line="841" name="req" /><variable citdl="best.get()" line="849" name="dist" /><variable citdl="" line="854" name="ws" /><variable citdl="required_by.get()" line="869" name="requirers" /><variable line="874" name="dependent_req" /><variable line="878" name="new_requirements" /><variable line="882" name="new_requirement" /></scope><scope doc="Find all activatable distributions in `plugin_env`&#10;&#10;Example usage::&#10;&#10;    distributions, errors = working_set.find_plugins(&#10;        Environment(plugin_dirlist)&#10;    )&#10;&#10;    map(working_set.add, distributions)&#10;&#10;    print('Could not load', errors)&#10;&#10;The `plugin_env` should be an ``Environment`` instance that contains&#10;only distributions that are in the project's &quot;plugin directory&quot; or&#10;directories. The `full_env`, if supplied, should be an ``Environment``&#10;contains all currently-available distributions.  If `full_env` is not&#10;supplied, one is created automatically from the ``WorkingSet`` this&#10;method is called on, which will typically mean that every directory on&#10;``sys.path`` will be scanned for distributions.&#10;&#10;`installer` is a standard installer callback as used by the&#10;``resolve()`` method. The `fallback` flag indicates whether we should&#10;attempt to resolve older versions of a plugin if the newest version&#10;cannot be resolved.&#10;&#10;This method returns a 2-tuple: (`distributions`, `error_info`), where&#10;`distributions` is a list of the distributions found in `plugin_env`&#10;that were loadable, along with any other distributions that are needed&#10;to resolve their dependencies.  `error_info` is a dictionary mapping&#10;unloadable plugin distributions to an exception instance describing the&#10;error that occurred. Usually this will be a ``DistributionNotFound`` or&#10;``VersionConflict`` instance." ilk="function" line="891" lineend="973" name="find_plugins" returns="tuple" signature="find_plugins(plugin_env, full_env=None, installer=None, fallback=True)"><variable citdl="WorkingSet" ilk="argument" line="891" name="self" /><variable ilk="argument" line="891" name="plugin_env" /><variable ilk="argument" line="891" name="full_env" /><variable ilk="argument" line="891" name="installer" /><variable citdl="True" ilk="argument" line="891" name="fallback" /><variable citdl="list()" line="927" name="plugin_projects" /><variable citdl="dict" line="931" name="error_info" /><variable citdl="dict" line="932" name="distributions" /><variable citdl="Environment()" line="935" name="env" /><variable citdl="self.__class__()" line="940" name="shadow_set" /><variable line="944" name="project_name" /><variable line="946" name="dist" /><variable citdl="list" line="948" name="req" /><variable citdl="shadow_set.resolve()" line="951" name="resolvees" /></scope><scope doc="Ensure that distributions matching `requirements` are activated&#10;&#10;`requirements` must be a string or a (possibly-nested) sequence&#10;thereof, specifying the distributions and versions required.  The&#10;return value is a sequence of the distributions that needed to be&#10;activated to fulfill the requirements; all relevant distributions are&#10;included, even if they were already activated in this working set." ilk="function" line="975" lineend="989" name="require" returns="resolve()" signature="require()"><variable attributes="varargs" citdl="WorkingSet" ilk="argument" line="975" name="self" /><variable citdl="resolve()" line="984" name="needed" /><variable line="986" name="dist" /></scope><scope doc="Invoke `callback` for all distributions&#10;&#10;If `existing=True` (default),&#10;call on all existing ones, as well." ilk="function" line="991" lineend="1003" name="subscribe" signature="subscribe(callback, existing=True)"><variable citdl="WorkingSet" ilk="argument" line="991" name="self" /><variable ilk="argument" line="991" name="callback" /><variable citdl="True" ilk="argument" line="991" name="existing" /><variable line="1002" name="dist" /></scope><scope attributes="protected" ilk="function" line="1005" lineend="1007" name="_added_new" signature="_added_new(dist)"><variable citdl="WorkingSet" ilk="argument" line="1005" name="self" /><variable ilk="argument" line="1005" name="dist" /><variable line="1006" name="callback" /></scope><scope ilk="function" line="1009" lineend="1011" name="__getstate__" returns="tuple" signature="__getstate__()"><variable citdl="WorkingSet" ilk="argument" line="1009" name="self" /></scope><scope ilk="function" line="1015" lineend="1020" name="__setstate__" signature="__setstate__(e_k_b_c)"><variable citdl="WorkingSet" ilk="argument" line="1015" name="self" /><variable ilk="argument" line="1015" name="e_k_b_c" /></scope></scope><scope attributes="protected" classrefs="dict" doc="Map each requirement to the extras that demanded it." ilk="class" line="1023" lineend="1040" name="_ReqExtras"><scope doc="Evaluate markers for req against each extra that&#10;demanded it.&#10;&#10;Return False if the req has a marker and fails&#10;evaluation. Otherwise, return True." ilk="function" line="1028" lineend="1040" name="markers_pass" returns="any()" signature="markers_pass(req, extras=None)"><variable citdl="_ReqExtras" ilk="argument" line="1028" name="self" /><variable ilk="argument" line="1028" name="req" /><variable ilk="argument" line="1028" name="extras" /><variable line="1036" name="extra_evals" /></scope></scope><scope classrefs="object" doc="Searchable snapshot of distributions on a search path" ilk="class" line="1043" lineend="1183" name="Environment"><scope attributes="__ctor__" doc="Snapshot distributions available on a search path&#10;&#10;Any distributions found on `search_path` are added to the environment.&#10;`search_path` should be a sequence of ``sys.path`` items.  If not&#10;supplied, ``sys.path`` is used.&#10;&#10;`platform` is an optional string specifying the name of the platform&#10;that platform-specific distributions must be compatible with.  If&#10;unspecified, it defaults to the current platform.  `python` is an&#10;optional string naming the desired version of Python (e.g. ``'3.3'``);&#10;it defaults to the current version.&#10;&#10;You may explicitly set `platform` (and/or `python`) to ``None`` if you&#10;wish to map *all* distributions, not just those compatible with the&#10;running platform or Python version." ilk="function" line="1046" lineend="1068" name="__init__" signature="Environment(search_path=None, platform=get_supported_platform(), python=PY_MAJOR)"><variable citdl="Environment" ilk="argument" line="1046" name="self" /><variable ilk="argument" line="1046" name="search_path" /><variable citdl="get_supported_platform()" ilk="argument" line="1046" name="platform" /><variable ilk="argument" line="1046" name="python" /></scope><variable attributes="protected __instancevar__" citdl="dict" line="1065" name="_distmap" /><variable attributes="__instancevar__" citdl="get_supported_platform()" line="1066" name="platform" /><variable attributes="__instancevar__" line="1067" name="python" /><scope doc="Is distribution `dist` acceptable for this environment?&#10;&#10;The distribution must match the platform and python version&#10;requirements specified when this environment was created, or False&#10;is returned." ilk="function" line="1070" lineend="1079" name="can_add" returns="compatible_platforms()" signature="can_add(dist)"><variable citdl="Environment" ilk="argument" line="1070" name="self" /><variable ilk="argument" line="1070" name="dist" /></scope><scope doc="Remove `dist` from the environment" ilk="function" line="1081" lineend="1083" name="remove" signature="remove(dist)"><variable citdl="Environment" ilk="argument" line="1081" name="self" /><variable ilk="argument" line="1081" name="dist" /></scope><scope doc="Scan `search_path` for distributions usable in this environment&#10;&#10;Any distributions found are added to the environment.&#10;`search_path` should be a sequence of ``sys.path`` items.  If not&#10;supplied, ``sys.path`` is used.  Only distributions conforming to&#10;the platform/python version defined at initialization are added." ilk="function" line="1085" lineend="1098" name="scan" signature="scan(search_path=None)"><variable citdl="Environment" ilk="argument" line="1085" name="self" /><variable citdl="sys.path" ilk="argument" line="1085" name="search_path" /><variable line="1096" name="item" /><variable line="1097" name="dist" /></scope><scope doc="Return a newest-to-oldest list of distributions for `project_name`&#10;&#10;Uses case-insensitive `project_name` comparison, assuming all the&#10;project's distributions use their project's name converted to all&#10;lowercase as their key." ilk="function" line="1100" lineend="1109" name="__getitem__" returns="self._distmap.get()" signature="__getitem__(project_name)"><variable citdl="Environment" ilk="argument" line="1100" name="self" /><variable ilk="argument" line="1100" name="project_name" /><variable citdl="project_name.lower()" line="1108" name="distribution_key" /></scope><scope doc="Add `dist` if we ``can_add()`` it and it has not already been added&#10;        " ilk="function" line="1111" lineend="1118" name="add" signature="add(dist)"><variable citdl="Environment" ilk="argument" line="1111" name="self" /><variable ilk="argument" line="1111" name="dist" /><variable citdl="self._distmap.setdefault()" line="1115" name="dists" /></scope><scope doc="Find distribution best matching `req` and usable on `working_set`&#10;&#10;This calls the ``find(req)`` method of the `working_set` to see if a&#10;suitable distribution is already active.  (This may raise&#10;``VersionConflict`` if an unsuitable version of the project is already&#10;active in the specified `working_set`.)  If a suitable distribution&#10;isn't active, this method returns the newest distribution in the&#10;environment that meets the ``Requirement`` in `req`.  If no suitable&#10;distribution is found, and `installer` is supplied, then the result of&#10;calling the environment's ``obtain(req, installer)`` method will be&#10;returned." ilk="function" line="1120" lineend="1146" name="best_match" returns="self.obtain()" signature="best_match(req, working_set, installer=None, replace_conflicting=False)"><variable citdl="Environment" ilk="argument" line="1120" name="self" /><variable ilk="argument" line="1120" name="req" /><variable ilk="argument" line="1120" name="working_set" /><variable ilk="argument" line="1120" name="installer" /><variable citdl="False" ilk="argument" line="1120" name="replace_conflicting" /><variable citdl="working_set.find()" line="1135" name="dist" /></scope><scope doc="Obtain a distribution matching `requirement` (e.g. via download)&#10;&#10;Obtain a distro that matches requirement (e.g. via download).  In the&#10;base ``Environment`` class, this routine just returns&#10;``installer(requirement)``, unless `installer` is None, in which case&#10;None is returned instead.  This method is a hook that allows subclasses&#10;to attempt other ways of obtaining a distribution before falling back&#10;to the `installer` argument." ilk="function" line="1148" lineend="1158" name="obtain" returns="Environment.obtain.installer()" signature="obtain(requirement, installer=None)"><variable citdl="Environment" ilk="argument" line="1148" name="self" /><variable ilk="argument" line="1148" name="requirement" /><variable ilk="argument" line="1148" name="installer" /></scope><scope doc="Yield the unique project names of the available distributions" ilk="function" line="1160" lineend="1164" name="__iter__" signature="__iter__()"><variable citdl="Environment" ilk="argument" line="1160" name="self" /><variable line="1162" name="key" /></scope><scope doc="In-place addition of a distribution or environment" ilk="function" line="1166" lineend="1176" name="__iadd__" returns="Environment" signature="__iadd__(other)"><variable citdl="Environment" ilk="argument" line="1166" name="self" /><variable ilk="argument" line="1166" name="other" /><variable line="1171" name="project" /><variable line="1172" name="dist" /></scope><scope doc="Add an environment or distribution to an environment" ilk="function" line="1178" lineend="1183" name="__add__" returns="self.__class__()" signature="__add__(other)"><variable citdl="Environment" ilk="argument" line="1178" name="self" /><variable ilk="argument" line="1178" name="other" /><variable citdl="self.__class__()" line="1180" name="new" /><variable line="1181" name="env" /></scope></scope><variable citdl="Environment" line="1187" name="AvailableDistributions" /><scope classrefs="RuntimeError" doc="An error occurred extracting a resource&#10;&#10;The following attributes are available from instances of this exception:&#10;&#10;manager&#10;    The resource manager that raised this exception&#10;&#10;cache_path&#10;    The base directory for resource extraction&#10;&#10;original_error&#10;    The exception instance that caused extraction to fail" ilk="class" line="1190" lineend="1203" name="ExtractionError" /><scope doc="Manage resource extraction and packages" ilk="class" line="1206" lineend="1382" name="ResourceManager"><variable line="1208" name="extraction_path" /><scope attributes="__ctor__" ilk="function" line="1210" lineend="1211" name="__init__" signature="ResourceManager()"><variable citdl="ResourceManager" ilk="argument" line="1210" name="self" /></scope><variable attributes="__instancevar__" citdl="dict" line="1211" name="cached_files" /><scope doc="Does the named resource exist?" ilk="function" line="1213" lineend="1215" name="resource_exists" signature="resource_exists(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" line="1213" name="self" /><variable ilk="argument" line="1213" name="package_or_requirement" /><variable ilk="argument" line="1213" name="resource_name" /></scope><scope doc="Is the named resource an existing directory?" ilk="function" line="1217" lineend="1220" name="resource_isdir" signature="resource_isdir(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" line="1217" name="self" /><variable ilk="argument" line="1217" name="package_or_requirement" /><variable ilk="argument" line="1217" name="resource_name" /></scope><scope doc="Return a true filesystem path for specified resource" ilk="function" line="1223" lineend="1226" name="resource_filename" signature="resource_filename(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" line="1223" name="self" /><variable ilk="argument" line="1223" name="package_or_requirement" /><variable ilk="argument" line="1223" name="resource_name" /></scope><scope doc="Return a readable file-like object for specified resource" ilk="function" line="1229" lineend="1232" name="resource_stream" signature="resource_stream(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" line="1229" name="self" /><variable ilk="argument" line="1229" name="package_or_requirement" /><variable ilk="argument" line="1229" name="resource_name" /></scope><scope doc="Return specified resource as a string" ilk="function" line="1235" lineend="1238" name="resource_string" signature="resource_string(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" line="1235" name="self" /><variable ilk="argument" line="1235" name="package_or_requirement" /><variable ilk="argument" line="1235" name="resource_name" /></scope><scope doc="List the contents of the named resource directory" ilk="function" line="1241" lineend="1244" name="resource_listdir" signature="resource_listdir(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" line="1241" name="self" /><variable ilk="argument" line="1241" name="package_or_requirement" /><variable ilk="argument" line="1241" name="resource_name" /></scope><scope doc="Give an error message for problems extracting file(s)" ilk="function" line="1247" lineend="1273" name="extraction_error" signature="extraction_error()"><variable citdl="ResourceManager" ilk="argument" line="1247" name="self" /><variable line="1250" name="old_exc" /><variable citdl="get_default_cache()" line="1251" name="cache_path" /><variable line="1253" name="tmpl" /><variable citdl="ExtractionError" line="1269" name="err" /></scope><scope doc="Return absolute location in cache for `archive_name` and `names`&#10;&#10;The parent directory of the resulting path will be created if it does&#10;not already exist.  `archive_name` should be the base filename of the&#10;enclosing egg (which may not be the name of the enclosing zipfile!),&#10;including its &quot;.egg&quot; extension.  `names`, if provided, should be a&#10;sequence of path name parts &quot;under&quot; the egg's extraction location.&#10;&#10;This method should only be called by resource providers that need to&#10;obtain an extraction location, and only for names they intend to&#10;extract, as it tracks the generated names for possible cleanup later." ilk="function" line="1275" lineend="1298" name="get_cache_path" returns="os.path.join()" signature="get_cache_path(archive_name, names=())"><variable citdl="ResourceManager" ilk="argument" line="1275" name="self" /><variable ilk="argument" line="1275" name="archive_name" /><variable citdl="tuple" ilk="argument" line="1275" name="names" /><variable citdl="get_default_cache()" line="1288" name="extract_path" /><variable citdl="os.path.join()" line="1289" name="target_path" /></scope><scope attributes="protected __staticmethod__" doc="If the default extraction path is overridden and set to an insecure&#10;location, such as /tmp, it opens up an opportunity for an attacker to&#10;replace an extracted file with an unauthorized payload. Warn the user&#10;if a known insecure location is used.&#10;&#10;See Distribute #375 for more details." ilk="function" line="1300" lineend="1300" name="_warn_unsafe_extraction_path" signature="_warn_unsafe_extraction_path(path) - staticmethod"><variable citdl="ResourceManager" ilk="argument" line="1300" name="path" /><variable line="1315" name="mode" /><variable line="1317" name="msg" /></scope><scope doc="Perform any platform-specific postprocessing of `tempname`&#10;&#10;This is where Mac header rewrites should be done; other platforms don't&#10;have anything special they should do.&#10;&#10;Resource providers should call this method ONLY after successfully&#10;extracting a compressed resource.  They must NOT call it on resources&#10;that are already in the filesystem.&#10;&#10;`tempname` is the current (temporary) name of the file, and `filename`&#10;is the name it will be renamed to by the caller after this routine&#10;returns." ilk="function" line="1326" lineend="1344" name="postprocess" signature="postprocess(tempname, filename)"><variable citdl="ResourceManager" ilk="argument" line="1326" name="self" /><variable ilk="argument" line="1326" name="tempname" /><variable ilk="argument" line="1326" name="filename" /><variable citdl="int" line="1343" name="mode" /></scope><scope doc="Set the base path where resources will be extracted to, if needed.&#10;&#10;If you do not call this routine before any extractions take place, the&#10;path defaults to the return value of ``get_default_cache()``.  (Which&#10;is based on the ``PYTHON_EGG_CACHE`` environment variable, with various&#10;platform-specific fallbacks.  See that routine's documentation for more&#10;details.)&#10;&#10;Resources are extracted to subdirectories of this path based upon&#10;information given by the ``IResourceProvider``.  You may set this to a&#10;temporary directory, but then you must call ``cleanup_resources()`` to&#10;delete the extracted files when done.  There is no guarantee that&#10;``cleanup_resources()`` will be able to remove all extracted files.&#10;&#10;(Note: you may not change the extraction path for a given resource&#10;manager once resources have been extracted, unless you first call&#10;``cleanup_resources()``.)" ilk="function" line="1346" lineend="1370" name="set_extraction_path" signature="set_extraction_path(path)"><variable citdl="ResourceManager" ilk="argument" line="1346" name="self" /><variable ilk="argument" line="1346" name="path" /></scope><scope doc="Delete all extracted resource files and directories, returning a list&#10;of the file and directory names that could not be successfully removed.&#10;This function does not have any concurrency protection, so it should&#10;generally only be called when the extraction path is a temporary&#10;directory exclusive to a single process.  This method is not&#10;automatically called; you must call it explicitly or register it as an&#10;``atexit`` function if you wish to ensure cleanup of a temporary&#10;directory used for extractions." ilk="function" line="1372" lineend="1382" name="cleanup_resources" signature="cleanup_resources(force=False)"><variable citdl="ResourceManager" ilk="argument" line="1372" name="self" /><variable citdl="False" ilk="argument" line="1372" name="force" /></scope></scope><scope doc="Return the ``PYTHON_EGG_CACHE`` environment variable&#10;or a platform-relevant user cache dir for an app&#10;named &quot;Python-Eggs&quot;." ilk="function" line="1386" lineend="1394" name="get_default_cache" returns="appdirs.user_cache_dir()" signature="get_default_cache()" /><scope doc="Convert an arbitrary string to a standard distribution name&#10;&#10;Any runs of non-alphanumeric/. characters are replaced with a single '-'." ilk="function" line="1398" lineend="1403" name="safe_name" returns="re.sub()" signature="safe_name(name)"><variable ilk="argument" line="1398" name="name" /></scope><scope doc="Convert an arbitrary string to a standard version string" ilk="function" line="1406" lineend="1415" name="safe_version" returns="re.sub()" signature="safe_version(version)"><variable citdl="version.replace()" ilk="argument" line="1406" name="version" /></scope><scope doc="Convert an arbitrary string to a standard 'extra' name&#10;&#10;Any runs of non-alphanumeric characters are replaced with a single '_',&#10;and the result is always lowercased." ilk="function" line="1418" lineend="1424" name="safe_extra" signature="safe_extra(extra)"><variable ilk="argument" line="1418" name="extra" /></scope><scope doc="Convert a project or version name to its filename-escaped form&#10;&#10;Any '-' characters are currently replaced with '_'." ilk="function" line="1427" lineend="1432" name="to_filename" returns="name.replace()" signature="to_filename(name)"><variable ilk="argument" line="1427" name="name" /></scope><scope doc="Validate text as a PEP 508 environment marker; return an exception&#10;if invalid or False otherwise." ilk="function" line="1435" lineend="1446" name="invalid_marker" returns="e" signature="invalid_marker(text)"><variable ilk="argument" line="1435" name="text" /></scope><scope doc="Evaluate a PEP 508 environment marker.&#10;Return a boolean indicating the marker result in this environment.&#10;Raise SyntaxError if marker is invalid.&#10;&#10;This implementation uses the 'pyparsing' module." ilk="function" line="1449" lineend="1461" name="evaluate_marker" returns="marker.evaluate()" signature="evaluate_marker(text, extra=None)"><variable ilk="argument" line="1449" name="text" /><variable ilk="argument" line="1449" name="extra" /><variable citdl="packaging.markers.Marker()" line="1458" name="marker" /></scope><scope doc="Try to implement resources and metadata for arbitrary PEP 302 loaders" ilk="class" line="1464" lineend="1560" name="NullProvider"><variable line="1467" name="egg_name" /><variable line="1468" name="egg_info" /><variable citdl="getattr()" line="1469" name="loader" /><scope attributes="__ctor__" ilk="function" line="1471" lineend="1473" name="__init__" signature="NullProvider(module)"><variable citdl="NullProvider" ilk="argument" line="1471" name="self" /><variable ilk="argument" line="1471" name="module" /></scope><variable attributes="__instancevar__" citdl="os.path.dirname()" line="1473" name="module_path" /><scope ilk="function" line="1475" lineend="1476" name="get_resource_filename" returns="self._fn()" signature="get_resource_filename(manager, resource_name)"><variable citdl="NullProvider" ilk="argument" line="1475" name="self" /><variable ilk="argument" line="1475" name="manager" /><variable ilk="argument" line="1475" name="resource_name" /></scope><scope ilk="function" line="1478" lineend="1479" name="get_resource_stream" returns="io.BytesIO()" signature="get_resource_stream(manager, resource_name)"><variable citdl="NullProvider" ilk="argument" line="1478" name="self" /><variable ilk="argument" line="1478" name="manager" /><variable ilk="argument" line="1478" name="resource_name" /></scope><scope ilk="function" line="1481" lineend="1482" name="get_resource_string" returns="self._get()" signature="get_resource_string(manager, resource_name)"><variable citdl="NullProvider" ilk="argument" line="1481" name="self" /><variable ilk="argument" line="1481" name="manager" /><variable ilk="argument" line="1481" name="resource_name" /></scope><scope ilk="function" line="1484" lineend="1485" name="has_resource" returns="self._has()" signature="has_resource(resource_name)"><variable citdl="NullProvider" ilk="argument" line="1484" name="self" /><variable ilk="argument" line="1484" name="resource_name" /></scope><scope ilk="function" line="1487" lineend="1488" name="has_metadata" returns="self._has()" signature="has_metadata(name)"><variable citdl="NullProvider" ilk="argument" line="1487" name="self" /><variable ilk="argument" line="1487" name="name" /></scope><scope ilk="function" line="1490" lineend="1494" name="get_metadata" returns="str" signature="get_metadata(name)"><variable citdl="NullProvider" ilk="argument" line="1490" name="self" /><variable ilk="argument" line="1490" name="name" /><variable citdl="self._get()" line="1493" name="value" /></scope><scope ilk="function" line="1496" lineend="1497" name="get_metadata_lines" returns="yield_lines()" signature="get_metadata_lines(name)"><variable citdl="NullProvider" ilk="argument" line="1496" name="self" /><variable ilk="argument" line="1496" name="name" /></scope><scope ilk="function" line="1499" lineend="1500" name="resource_isdir" returns="self._isdir()" signature="resource_isdir(resource_name)"><variable citdl="NullProvider" ilk="argument" line="1499" name="self" /><variable ilk="argument" line="1499" name="resource_name" /></scope><scope ilk="function" line="1502" lineend="1503" name="metadata_isdir" returns="self._isdir()" signature="metadata_isdir(name)"><variable citdl="NullProvider" ilk="argument" line="1502" name="self" /><variable ilk="argument" line="1502" name="name" /></scope><scope ilk="function" line="1505" lineend="1506" name="resource_listdir" returns="self._listdir()" signature="resource_listdir(resource_name)"><variable citdl="NullProvider" ilk="argument" line="1505" name="self" /><variable ilk="argument" line="1505" name="resource_name" /></scope><scope ilk="function" line="1508" lineend="1511" name="metadata_listdir" returns="list" signature="metadata_listdir(name)"><variable citdl="NullProvider" ilk="argument" line="1508" name="self" /><variable ilk="argument" line="1508" name="name" /></scope><scope ilk="function" line="1513" lineend="1534" name="run_script" signature="run_script(script_name, namespace)"><import line="1529" module="linecache" symbol="cache" /><variable citdl="NullProvider" ilk="argument" line="1513" name="self" /><variable ilk="argument" line="1513" name="script_name" /><variable ilk="argument" line="1513" name="namespace" /><variable line="1514" name="script" /><variable citdl="script_text.replace()" line="1520" name="script_text" /><variable citdl="self._fn()" line="1522" name="script_filename" /><variable line="1525" name="source" /><variable citdl="compile()" line="1526" name="code" /><variable citdl="compile()" line="1533" name="script_code" /></scope><scope attributes="protected" ilk="function" line="1536" lineend="1538" name="_has" signature="_has(path)"><variable citdl="NullProvider" ilk="argument" line="1536" name="self" /><variable ilk="argument" line="1536" name="path" /></scope><scope attributes="protected" ilk="function" line="1541" lineend="1543" name="_isdir" signature="_isdir(path)"><variable citdl="NullProvider" ilk="argument" line="1541" name="self" /><variable ilk="argument" line="1541" name="path" /></scope><scope attributes="protected" ilk="function" line="1546" lineend="1548" name="_listdir" signature="_listdir(path)"><variable citdl="NullProvider" ilk="argument" line="1546" name="self" /><variable ilk="argument" line="1546" name="path" /></scope><scope attributes="protected" ilk="function" line="1551" lineend="1554" name="_fn" returns="os.path.join()" signature="_fn(base, resource_name)"><variable citdl="NullProvider" ilk="argument" line="1551" name="self" /><variable ilk="argument" line="1551" name="base" /><variable ilk="argument" line="1551" name="resource_name" /></scope><scope attributes="protected" ilk="function" line="1556" lineend="1560" name="_get" returns="self.loader.get_data()" signature="_get(path)"><variable citdl="NullProvider" ilk="argument" line="1556" name="self" /><variable ilk="argument" line="1556" name="path" /></scope></scope><scope classrefs="NullProvider" doc="Provider based on a virtual filesystem" ilk="class" line="1567" lineend="1586" name="EggProvider"><scope attributes="__ctor__" ilk="function" line="1570" lineend="1572" name="__init__" signature="EggProvider(module)"><variable citdl="EggProvider" ilk="argument" line="1570" name="self" /><variable ilk="argument" line="1570" name="module" /></scope><scope attributes="protected" ilk="function" line="1574" lineend="1586" name="_setup_prefix" signature="_setup_prefix()"><variable citdl="EggProvider" ilk="argument" line="1574" name="self" /><variable citdl="self.module_path" line="1577" name="path" /><variable citdl="self.module_path" line="1578" name="old" /><variable line="1586" name="base" /></scope><variable attributes="__instancevar__" citdl="os.path.basename()" line="1581" name="egg_name" /><variable attributes="__instancevar__" citdl="os.path.join()" line="1582" name="egg_info" /><variable attributes="__instancevar__" citdl="self.module_path" line="1583" name="egg_root" /></scope><scope classrefs="EggProvider" doc="Provides access to package resources in the filesystem" ilk="class" line="1589" lineend="1608" name="DefaultProvider"><scope attributes="protected" ilk="function" line="1592" lineend="1593" name="_has" returns="os.path.exists()" signature="_has(path)"><variable citdl="DefaultProvider" ilk="argument" line="1592" name="self" /><variable ilk="argument" line="1592" name="path" /></scope><scope attributes="protected" ilk="function" line="1595" lineend="1596" name="_isdir" returns="os.path.isdir()" signature="_isdir(path)"><variable citdl="DefaultProvider" ilk="argument" line="1595" name="self" /><variable ilk="argument" line="1595" name="path" /></scope><scope attributes="protected" ilk="function" line="1598" lineend="1599" name="_listdir" returns="os.listdir()" signature="_listdir(path)"><variable citdl="DefaultProvider" ilk="argument" line="1598" name="self" /><variable ilk="argument" line="1598" name="path" /></scope><scope ilk="function" line="1601" lineend="1602" name="get_resource_stream" returns="open()" signature="get_resource_stream(manager, resource_name)"><variable citdl="DefaultProvider" ilk="argument" line="1601" name="self" /><variable ilk="argument" line="1601" name="manager" /><variable ilk="argument" line="1601" name="resource_name" /></scope><scope attributes="protected" ilk="function" line="1604" lineend="1606" name="_get" returns="stream.read()" signature="_get(path)"><variable citdl="DefaultProvider" ilk="argument" line="1604" name="self" /><variable ilk="argument" line="1604" name="path" /></scope><scope attributes="protected __classmethod__" ilk="function" line="1608" lineend="1608" name="_register" signature="_register() - classmethod"><variable citdl="DefaultProvider" ilk="argument" line="1608" name="cls" /><variable citdl="getattr()" line="1610" name="loader_cls" /></scope></scope><scope classrefs="NullProvider" doc="Provider that returns nothing for all requests" ilk="class" line="1621" lineend="1630" name="EmptyProvider"><variable attributes="protected" line="1624" name="_isdir" /><variable attributes="protected" line="1625" name="_get" /><variable attributes="protected" line="1626" name="_listdir" /><variable line="1627" name="module_path" /><scope attributes="__ctor__" ilk="function" line="1629" lineend="1630" name="__init__" signature="EmptyProvider()"><variable citdl="EmptyProvider" ilk="argument" line="1629" name="self" /></scope></scope><variable citdl="EmptyProvider" line="1633" name="empty_provider" /><scope classrefs="dict" doc="zip manifest builder" ilk="class" line="1636" lineend="1660" name="ZipManifests"><scope attributes="__classmethod__" doc="Build a dictionary similar to the zipimport directory&#10;caches, except instead of tuples, store ZipInfo objects.&#10;&#10;Use a platform-specific path separator (os.sep) for the path keys&#10;for compatibility with pypy on Windows." ilk="function" line="1641" lineend="1641" name="build" returns="dict()" signature="build(path) - classmethod"><variable citdl="ZipManifests" ilk="argument" line="1641" name="cls" /><variable ilk="argument" line="1641" name="path" /><variable line="1651" name="items" /></scope><variable citdl="ZipManifests.build" line="1660" name="load" /></scope><scope classrefs="ZipManifests" doc="Memoized zipfile manifests." ilk="class" line="1663" lineend="1680" name="MemoizedZipManifests"><variable citdl="collections.namedtuple()" line="1667" name="manifest_mod" /><scope doc="Load a manifest at path or return a suitable manifest already loaded." ilk="function" line="1669" lineend="1680" name="load" signature="load(path)"><variable citdl="MemoizedZipManifests" ilk="argument" line="1669" name="self" /><variable citdl="os.path.normpath()" ilk="argument" line="1669" name="path" /><variable line="1674" name="mtime" /><variable citdl="self.build()" line="1677" name="manifest" /></scope></scope><scope classrefs="EggProvider" doc="Resource support for zips and eggs" ilk="class" line="1683" lineend="1852" name="ZipProvider"><variable citdl="list" line="1686" name="eagers" /><variable attributes="protected" citdl="MemoizedZipManifests" line="1687" name="_zip_manifests" /><scope attributes="__ctor__" ilk="function" line="1689" lineend="1691" name="__init__" signature="ZipProvider(module)"><variable citdl="ZipProvider" ilk="argument" line="1689" name="self" /><variable ilk="argument" line="1689" name="module" /></scope><variable attributes="__instancevar__" line="1691" name="zip_pre" /><scope attributes="protected" ilk="function" line="1693" lineend="1702" name="_zipinfo_name" returns="str" signature="_zipinfo_name(fspath)"><variable citdl="ZipProvider" ilk="argument" line="1693" name="self" /><variable citdl="fspath.rstrip()" ilk="argument" line="1693" name="fspath" /></scope><scope attributes="protected" ilk="function" line="1705" lineend="1712" name="_parts" signature="_parts(zip_path)"><variable citdl="ZipProvider" ilk="argument" line="1705" name="self" /><variable ilk="argument" line="1705" name="zip_path" /><variable line="1708" name="fspath" /></scope><variable attributes="property" citdl="self._zip_manifests.load()" line="1715" name="zipinfo" /><scope attributes="__hidden__" ilk="function" line="1715" lineend="1715" name="zipinfo (property getter)" returns="self._zip_manifests.load()" signature="zipinfo (property getter)()"><variable citdl="ZipProvider" ilk="argument" line="1715" name="self" /></scope><scope ilk="function" line="1719" lineend="1730" name="get_resource_filename" returns="self._extract_resource()" signature="get_resource_filename(manager, resource_name)"><variable citdl="ZipProvider" ilk="argument" line="1719" name="self" /><variable ilk="argument" line="1719" name="manager" /><variable ilk="argument" line="1719" name="resource_name" /><variable citdl="self._resource_to_zip()" line="1725" name="zip_path" /><variable citdl="self._get_eager_resources()" line="1726" name="eagers" /><variable line="1728" name="name" /></scope><scope attributes="protected __staticmethod__" ilk="function" line="1732" lineend="1732" name="_get_date_and_size" returns="tuple" signature="_get_date_and_size(zip_stat) - staticmethod"><variable citdl="ZipProvider" ilk="argument" line="1732" name="zip_stat" /><variable citdl="zip_stat.file_size" line="1734" name="size" /><variable line="1736" name="date_time" /><variable citdl="time.mktime()" line="1738" name="timestamp" /></scope><scope attributes="protected" ilk="function" line="1741" lineend="1794" name="_extract_resource" returns="manager.get_cache_path()" signature="_extract_resource(manager, zip_path)"><variable citdl="ZipProvider" ilk="argument" line="1741" name="self" /><variable ilk="argument" line="1741" name="manager" /><variable ilk="argument" line="1741" name="zip_path" /><variable line="1744" name="name" /><variable citdl="()" line="1745" name="last" /><variable line="1751" name="timestamp" /><variable line="1751" name="size" /><variable citdl="manager.get_cache_path()" line="1758" name="real_path" /><variable line="1765" name="outf" /><variable line="1765" name="tmpnam" /></scope><scope attributes="protected" doc="Return True if the file_path is current for this zip_path" ilk="function" line="1796" lineend="1810" name="_is_current" returns="bool" signature="_is_current(file_path, zip_path)"><variable citdl="ZipProvider" ilk="argument" line="1796" name="self" /><variable ilk="argument" line="1796" name="file_path" /><variable ilk="argument" line="1796" name="zip_path" /><variable line="1800" name="size" /><variable line="1800" name="timestamp" /><variable citdl="os.stat()" line="1803" name="stat" /><variable citdl="self.loader.get_data()" line="1807" name="zip_contents" /><variable citdl="f.read()" line="1809" name="file_contents" /></scope><scope attributes="protected" ilk="function" line="1812" lineend="1819" name="_get_eager_resources" returns="list" signature="_get_eager_resources()"><variable citdl="ZipProvider" ilk="argument" line="1812" name="self" /><variable citdl="list" line="1814" name="eagers" /><variable line="1815" name="name" /></scope><scope attributes="protected" ilk="function" line="1821" lineend="1836" name="_index" returns="self._dirindex" signature="_index()"><variable citdl="ZipProvider" ilk="argument" line="1821" name="self" /><variable citdl="dict" line="1825" name="ind" /><variable line="1826" name="path" /><variable citdl="path.split()" line="1827" name="parts" /><variable citdl="os.sep.join()" line="1829" name="parent" /></scope><variable attributes="protected __instancevar__" citdl="dict" line="1835" name="_dirindex" /><scope attributes="protected" ilk="function" line="1838" lineend="1840" name="_has" returns="bool" signature="_has(fspath)"><variable citdl="ZipProvider" ilk="argument" line="1838" name="self" /><variable ilk="argument" line="1838" name="fspath" /><variable citdl="_zipinfo_name()" line="1839" name="zip_path" /></scope><scope attributes="protected" ilk="function" line="1842" lineend="1843" name="_isdir" returns="bool" signature="_isdir(fspath)"><variable citdl="ZipProvider" ilk="argument" line="1842" name="self" /><variable ilk="argument" line="1842" name="fspath" /></scope><scope attributes="protected" ilk="function" line="1845" lineend="1846" name="_listdir" returns="list()" signature="_listdir(fspath)"><variable citdl="ZipProvider" ilk="argument" line="1845" name="self" /><variable ilk="argument" line="1845" name="fspath" /></scope><scope attributes="protected" ilk="function" line="1848" lineend="1849" name="_eager_to_zip" returns="ZipProvider._zipinfo_name()" signature="_eager_to_zip(resource_name)"><variable citdl="ZipProvider" ilk="argument" line="1848" name="self" /><variable ilk="argument" line="1848" name="resource_name" /></scope><scope attributes="protected" ilk="function" line="1851" lineend="1852" name="_resource_to_zip" returns="ZipProvider._zipinfo_name()" signature="_resource_to_zip(resource_name)"><variable citdl="ZipProvider" ilk="argument" line="1851" name="self" /><variable ilk="argument" line="1851" name="resource_name" /></scope></scope><scope classrefs="EmptyProvider" doc="Metadata handler for standalone PKG-INFO files&#10;&#10;Usage::&#10;&#10;    metadata = FileMetadata(&quot;/path/to/PKG-INFO&quot;)&#10;&#10;This provider rejects all data and metadata requests except for PKG-INFO,&#10;which is treated as existing, and will be the contents of the file at&#10;the provided location." ilk="class" line="1858" lineend="1894" name="FileMetadata"><scope attributes="__ctor__" ilk="function" line="1870" lineend="1871" name="__init__" signature="FileMetadata(path)"><variable citdl="FileMetadata" ilk="argument" line="1870" name="self" /><variable ilk="argument" line="1870" name="path" /></scope><variable attributes="__instancevar__" line="1871" name="path" /><scope ilk="function" line="1873" lineend="1874" name="has_metadata" returns="bool" signature="has_metadata(name)"><variable citdl="FileMetadata" ilk="argument" line="1873" name="self" /><variable ilk="argument" line="1873" name="name" /></scope><scope ilk="function" line="1876" lineend="1883" name="get_metadata" returns="f.read()" signature="get_metadata(name)"><variable citdl="FileMetadata" ilk="argument" line="1876" name="self" /><variable ilk="argument" line="1876" name="name" /><variable citdl="f.read()" line="1881" name="metadata" /></scope><scope attributes="protected" ilk="function" line="1885" lineend="1891" name="_warn_on_replacement" signature="_warn_on_replacement(metadata)"><variable citdl="FileMetadata" ilk="argument" line="1885" name="self" /><variable ilk="argument" line="1885" name="metadata" /><variable citdl="__builtins__.bytes.decode()" line="1887" name="replacement_char" /><variable citdl="str" line="1889" name="tmpl" /><variable citdl="tmpl.format()" line="1890" name="msg" /></scope><scope ilk="function" line="1893" lineend="1894" name="get_metadata_lines" returns="yield_lines()" signature="get_metadata_lines(name)"><variable citdl="FileMetadata" ilk="argument" line="1893" name="self" /><variable ilk="argument" line="1893" name="name" /></scope></scope><scope classrefs="DefaultProvider" doc="Metadata provider for egg directories&#10;&#10;Usage::&#10;&#10;&#10;&#10;    egg_info = &quot;/path/to/PackageName.egg-info&quot;&#10;    base_dir = os.path.dirname(egg_info)&#10;    metadata = PathMetadata(base_dir, egg_info)&#10;    dist_name = os.path.splitext(os.path.basename(egg_info))[0]&#10;    dist = Distribution(basedir, project_name=dist_name, metadata=metadata)&#10;&#10;&#10;&#10;    egg_path = &quot;/path/to/PackageName-ver-pyver-etc.egg&quot;&#10;    metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))&#10;    dist = Distribution.from_filename(egg_path, metadata=metadata)" ilk="class" line="1897" lineend="1919" name="PathMetadata"><scope attributes="__ctor__" ilk="function" line="1917" lineend="1919" name="__init__" signature="PathMetadata(path, egg_info)"><variable citdl="PathMetadata" ilk="argument" line="1917" name="self" /><variable ilk="argument" line="1917" name="path" /><variable ilk="argument" line="1917" name="egg_info" /></scope><variable attributes="__instancevar__" line="1918" name="module_path" /><variable attributes="__instancevar__" line="1919" name="egg_info" /></scope><scope classrefs="ZipProvider" doc="Metadata provider for .egg files" ilk="class" line="1922" lineend="1934" name="EggMetadata"><scope attributes="__ctor__" doc="Create a metadata provider from a zipimporter" ilk="function" line="1925" lineend="1934" name="__init__" signature="EggMetadata(importer)"><variable citdl="EggMetadata" ilk="argument" line="1925" name="self" /><variable ilk="argument" line="1925" name="importer" /></scope><variable attributes="__instancevar__" line="1928" name="zip_pre" /><variable attributes="__instancevar__" line="1929" name="loader" /><variable attributes="__instancevar__" citdl="importer.archive" line="1931" name="module_path" /></scope><scope doc="Register `distribution_finder` to find distributions in sys.path items&#10;&#10;`importer_type` is the type or class of a PEP 302 &quot;Importer&quot; (sys.path item&#10;handler), and `distribution_finder` is a callable that, passed a path&#10;item and the importer instance, yields ``Distribution`` instances found on&#10;that path item.  See ``pkg_resources.find_on_path`` for an example." ilk="function" line="1940" lineend="1947" name="register_finder" signature="register_finder(importer_type, distribution_finder)"><variable ilk="argument" line="1940" name="importer_type" /><variable ilk="argument" line="1940" name="distribution_finder" /></scope><scope doc="Yield distributions accessible via `path_item`" ilk="function" line="1950" lineend="1954" name="find_distributions" returns="find_distributions.finder()" signature="find_distributions(path_item, only=False)"><variable ilk="argument" line="1950" name="path_item" /><variable citdl="False" ilk="argument" line="1950" name="only" /><variable citdl="get_importer()" line="1952" name="importer" /><variable citdl="_find_adapter()" line="1953" name="finder" /></scope><scope doc="Find eggs in zip files; possibly multiple nested eggs." ilk="function" line="1957" lineend="1981" name="find_eggs_in_zip" signature="find_eggs_in_zip(importer, path_item, only=False)"><variable ilk="argument" line="1957" name="importer" /><variable ilk="argument" line="1957" name="path_item" /><variable citdl="False" ilk="argument" line="1957" name="only" /><variable citdl="EggMetadata" line="1965" name="metadata" /><variable line="1971" name="subitem" /><variable citdl="os.path.join()" line="1973" name="subpath" /><variable citdl="()" line="1974" name="dists" /><variable line="1975" name="dist" /><variable citdl="EggMetadata" line="1979" name="submeta" /></scope><scope ilk="function" line="1987" lineend="1988" name="find_nothing" returns="tuple" signature="find_nothing(importer, path_item, only=False)"><variable ilk="argument" line="1987" name="importer" /><variable ilk="argument" line="1987" name="path_item" /><variable citdl="False" ilk="argument" line="1987" name="only" /></scope><scope attributes="protected" doc="Given a list of filenames, return them in descending order&#10;by version number.&#10;&#10;&gt;&gt;&gt; names = 'bar', 'foo', 'Python-2.7.10.egg', 'Python-2.7.2.egg'&#10;&gt;&gt;&gt; _by_version_descending(names)&#10;['Python-2.7.10.egg', 'Python-2.7.2.egg', 'foo', 'bar']&#10;&gt;&gt;&gt; names = 'Setuptools-1.2.3b1.egg', 'Setuptools-1.2.3.egg'&#10;&gt;&gt;&gt; _by_version_descending(names)&#10;['Setuptools-1.2.3.egg', 'Setuptools-1.2.3b1.egg']&#10;&gt;&gt;&gt; names = 'Setuptools-1.2.3b1.egg', 'Setuptools-1.2.3.post1.egg'&#10;&gt;&gt;&gt; _by_version_descending(names)&#10;['Setuptools-1.2.3.post1.egg', 'Setuptools-1.2.3b1.egg']" ilk="function" line="1994" lineend="2017" name="_by_version_descending" returns="sorted()" signature="_by_version_descending(names)"><variable ilk="argument" line="1994" name="names" /><scope attributes="protected" doc="Parse each component of the filename" ilk="function" line="2009" lineend="2015" name="_by_version" returns="list" signature="_by_version(name)"><variable ilk="argument" line="2009" name="name" /><variable line="2013" name="ext" /><variable citdl="itertools.chain()" line="2014" name="parts" /></scope></scope><scope doc="Yield distributions accessible on a sys.path directory" ilk="function" line="2020" lineend="2049" name="find_on_path" signature="find_on_path(importer, path_item, only=False)"><variable ilk="argument" line="2020" name="importer" /><variable citdl="_normalize_cached()" ilk="argument" line="2020" name="path_item" /><variable citdl="False" ilk="argument" line="2020" name="only" /><variable citdl="safe_listdir()" line="2032" name="entries" /><variable line="2037" name="filtered" /><variable citdl="_by_version_descending()" line="2044" name="path_item_entries" /><variable line="2045" name="entry" /><variable citdl="os.path.join()" line="2046" name="fullpath" /><variable citdl="dist_factory()" line="2047" name="factory" /><variable line="2048" name="dist" /></scope><scope doc="Return a dist_factory for a path_item and entry" ilk="function" line="2052" lineend="2065" name="dist_factory" signature="dist_factory(path_item, entry, only)"><variable ilk="argument" line="2052" name="path_item" /><variable ilk="argument" line="2052" name="entry" /><variable ilk="argument" line="2052" name="only" /><variable citdl="entry.lower()" line="2056" name="lower" /><variable citdl="any()" line="2057" name="is_meta" /></scope><scope doc="&gt;&gt;&gt; bool(NoDists())&#10;False&#10;&#10;&gt;&gt;&gt; list(NoDists()('anything'))&#10;[]" ilk="class" line="2069" lineend="2083" name="NoDists"><scope ilk="function" line="2077" lineend="2078" name="__bool__" returns="bool" signature="__bool__()"><variable citdl="NoDists" ilk="argument" line="2077" name="self" /></scope><variable citdl="NoDists.__bool__" line="2080" name="__nonzero__" /><scope ilk="function" line="2082" lineend="2083" name="__call__" returns="iter()" signature="__call__(fullpath)"><variable citdl="NoDists" ilk="argument" line="2082" name="self" /><variable ilk="argument" line="2082" name="fullpath" /></scope></scope><scope doc="Attempt to list contents of path, but suppress some exceptions." ilk="function" line="2086" lineend="2104" name="safe_listdir" returns="os.listdir()" signature="safe_listdir(path)"><variable ilk="argument" line="2086" name="path" /><variable citdl="bool" line="2097" name="ignorable" /></scope><scope ilk="function" line="2107" lineend="2118" name="distributions_from_metadata" signature="distributions_from_metadata(path)"><variable ilk="argument" line="2107" name="path" /><variable citdl="os.path.dirname()" line="2108" name="root" /><variable citdl="FileMetadata" line="2113" name="metadata" /><variable citdl="os.path.basename()" line="2116" name="entry" /></scope><scope doc="Yield non-empty lines from file at path" ilk="function" line="2122" lineend="2130" name="non_empty_lines" signature="non_empty_lines(path)"><variable ilk="argument" line="2122" name="path" /><variable citdl="line.strip()" line="2127" name="line" /></scope><scope doc="Given a path to an .egg-link, resolve distributions&#10;present in the referenced path." ilk="function" line="2133" lineend="2144" name="resolve_egg_link" returns="next()" signature="resolve_egg_link(path)"><variable ilk="argument" line="2133" name="path" /><variable citdl="non_empty_lines()" line="2138" name="referenced_paths" /><variable line="2139" name="resolved_paths" /><variable citdl="map()" line="2143" name="dist_groups" /></scope><scope doc="Register `namespace_handler` to declare namespace packages&#10;&#10;`importer_type` is the type or class of a PEP 302 &quot;Importer&quot; (sys.path item&#10;handler), and `namespace_handler` is a callable like this::&#10;&#10;    def namespace_handler(importer, path_entry, moduleName, module):&#10;&#10;&#10;Namespace handlers are only called if the importer object has already&#10;agreed that it can handle the relevant path item, and they should only&#10;return a subpath if the module __path__ does not already contain an&#10;equivalent subpath.  For an example namespace handler, see&#10;``pkg_resources.file_ns_handler``." ilk="function" line="2156" lineend="2171" name="register_namespace_handler" signature="register_namespace_handler(importer_type, namespace_handler)"><variable ilk="argument" line="2156" name="importer_type" /><variable ilk="argument" line="2156" name="namespace_handler" /></scope><scope attributes="protected" doc="Ensure that named package includes a subpath of path_item (if needed)" ilk="function" line="2174" lineend="2197" name="_handle_ns" returns="handler()" signature="_handle_ns(packageName, path_item)"><variable ilk="argument" line="2174" name="packageName" /><variable ilk="argument" line="2174" name="path_item" /><variable citdl="get_importer()" line="2177" name="importer" /><variable citdl="importer.find_module()" line="2180" name="loader" /><variable citdl="types.ModuleType()" line="2183" name="module" /><variable citdl="_find_adapter()" line="2190" name="handler" /><variable citdl="handler()" line="2191" name="subpath" /><variable citdl="list" line="2193" name="path" /></scope><scope attributes="protected" doc="Rebuild module.__path__ ensuring that all entries are ordered&#10;corresponding to their sys.path order" ilk="function" line="2200" lineend="2230" name="_rebuild_mod_path" signature="_rebuild_mod_path(orig_path, package_name, module)"><variable ilk="argument" line="2200" name="orig_path" /><variable ilk="argument" line="2200" name="package_name" /><variable ilk="argument" line="2200" name="module" /><variable citdl="list" line="2205" name="sys_path" /><scope doc="Workaround for #520 and #513." ilk="function" line="2207" lineend="2214" name="safe_sys_path_index" returns="float()" signature="safe_sys_path_index(entry)"><variable ilk="argument" line="2207" name="entry" /></scope><scope doc="Return the ordinal of the path based on its position in sys.path" ilk="function" line="2216" lineend="2223" name="position_in_sys_path" returns="_rebuild_mod_path.safe_sys_path_index()" signature="position_in_sys_path(path)"><variable ilk="argument" line="2216" name="path" /><variable citdl="path.split()" line="2220" name="path_parts" /><variable line="2221" name="module_parts" /><variable line="2222" name="parts" /></scope></scope><scope doc="Declare that package 'packageName' is a namespace package" ilk="function" line="2233" lineend="2263" name="declare_namespace" signature="declare_namespace(packageName)"><variable ilk="argument" line="2233" name="packageName" /><variable citdl="sys.path" line="2241" name="path" /><variable citdl="__builtins__.str.join()" line="2241" name="parent" /><variable line="2257" name="path_item" /></scope><scope doc="Ensure that previously-declared namespace packages include path_item" ilk="function" line="2266" lineend="2275" name="fixup_namespace_packages" signature="fixup_namespace_packages(path_item, parent=None)"><variable ilk="argument" line="2266" name="path_item" /><variable ilk="argument" line="2266" name="parent" /><variable line="2270" name="package" /><variable citdl="_handle_ns()" line="2271" name="subpath" /></scope><scope doc="Compute an ns-package subpath for a filesystem or zipfile importer" ilk="function" line="2278" lineend="2288" name="file_ns_handler" returns="os.path.join()" signature="file_ns_handler(importer, path_item, packageName, module)"><variable ilk="argument" line="2278" name="importer" /><variable ilk="argument" line="2278" name="path_item" /><variable ilk="argument" line="2278" name="packageName" /><variable ilk="argument" line="2278" name="module" /><variable citdl="os.path.join()" line="2281" name="subpath" /><variable citdl="_normalize_cached()" line="2282" name="normalized" /><variable line="2283" name="item" /></scope><scope ilk="function" line="2298" lineend="2299" name="null_ns_handler" signature="null_ns_handler(importer, path_item, packageName, module)"><variable ilk="argument" line="2298" name="importer" /><variable ilk="argument" line="2298" name="path_item" /><variable ilk="argument" line="2298" name="packageName" /><variable ilk="argument" line="2298" name="module" /></scope><scope doc="Normalize a file/dir name for comparison purposes" ilk="function" line="2305" lineend="2307" name="normalize_path" returns="os.path.normcase()" signature="normalize_path(filename)"><variable ilk="argument" line="2305" name="filename" /></scope><scope attributes="protected" ilk="function" line="2310" lineend="2315" name="_normalize_cached" returns="result" signature="_normalize_cached(filename, _cache={})"><variable ilk="argument" line="2310" name="filename" /><variable citdl="dict" ilk="argument" line="2310" name="_cache" /></scope><scope attributes="protected" doc="Determine if given path appears to be an egg." ilk="function" line="2318" lineend="2322" name="_is_egg_path" signature="_is_egg_path(path)"><variable ilk="argument" line="2318" name="path" /></scope><scope attributes="protected" doc="Determine if given path appears to be an unpacked egg." ilk="function" line="2325" lineend="2331" name="_is_unpacked_egg" returns="_is_egg_path()" signature="_is_unpacked_egg(path)"><variable ilk="argument" line="2325" name="path" /></scope><scope attributes="protected" ilk="function" line="2335" lineend="2340" name="_set_parent_ns" signature="_set_parent_ns(packageName)"><variable ilk="argument" line="2335" name="packageName" /><variable citdl="packageName.split()" line="2336" name="parts" /><variable citdl="parts.pop()" line="2337" name="name" /><variable citdl="__builtins__.str.join()" line="2339" name="parent" /></scope><scope doc="Yield non-empty/non-comment lines of a string or sequence" ilk="function" line="2343" lineend="2354" name="yield_lines" signature="yield_lines(strs)"><variable ilk="argument" line="2343" name="strs" /><variable citdl="s.strip()" line="2346" name="s" /><variable line="2352" name="ss" /></scope><variable line="2357" name="MODULE" /><variable line="2358" name="EGG_NAME" /><scope classrefs="object" doc="Object representing an advertised importable object" ilk="class" line="2372" lineend="2484" name="EntryPoint"><scope attributes="__ctor__" ilk="function" line="2375" lineend="2382" name="__init__" signature="EntryPoint(name, module_name, attrs=(), extras=(), dist=None)"><variable citdl="EntryPoint" ilk="argument" line="2375" name="self" /><variable ilk="argument" line="2375" name="name" /><variable ilk="argument" line="2375" name="module_name" /><variable citdl="tuple" ilk="argument" line="2375" name="attrs" /><variable citdl="tuple" ilk="argument" line="2375" name="extras" /><variable ilk="argument" line="2375" name="dist" /></scope><variable attributes="__instancevar__" line="2378" name="name" /><variable attributes="__instancevar__" line="2379" name="module_name" /><variable attributes="__instancevar__" citdl="tuple()" line="2380" name="attrs" /><variable attributes="__instancevar__" citdl="tuple()" line="2381" name="extras" /><variable attributes="__instancevar__" line="2382" name="dist" /><scope ilk="function" line="2384" lineend="2390" name="__str__" signature="__str__()"><variable citdl="EntryPoint" ilk="argument" line="2384" name="self" /><variable line="2385" name="s" /></scope><scope ilk="function" line="2392" lineend="2393" name="__repr__" signature="__repr__()"><variable citdl="EntryPoint" ilk="argument" line="2392" name="self" /></scope><scope doc="Require packages for this EntryPoint, then resolve it." ilk="function" line="2395" lineend="2408" name="load" returns="self.resolve()" signature="load(**require)"><variable attributes="varargs" citdl="EntryPoint" ilk="argument" line="2395" name="self" /><variable attributes="kwargs" ilk="argument" line="2395" name="require" /></scope><scope doc="Resolve the entry point from its module and attrs." ilk="function" line="2410" lineend="2418" name="resolve" returns="functools.reduce()" signature="resolve()"><variable citdl="EntryPoint" ilk="argument" line="2410" name="self" /><variable citdl="__import__()" line="2414" name="module" /></scope><scope ilk="function" line="2420" lineend="2431" name="require" signature="require(env=None, installer=None)"><variable citdl="EntryPoint" ilk="argument" line="2420" name="self" /><variable ilk="argument" line="2420" name="env" /><variable ilk="argument" line="2420" name="installer" /><variable citdl="self.dist.requires()" line="2429" name="reqs" /><variable citdl="working_set.resolve()" line="2430" name="items" /></scope><variable citdl="re.compile()" line="2433" name="pattern" /><scope attributes="__classmethod__" doc="Parse a single entry point from string `src`&#10;&#10;Entry point syntax follows the form::&#10;&#10;    name = some.module:some.attr [extra1, extra2]&#10;&#10;The entry name and module name are required, but the ``:attrs`` and&#10;``[extras]`` parts are optional" ilk="function" line="2442" lineend="2442" name="parse" returns="EntryPoint.parse.cls()" signature="parse(src, dist=None) - classmethod"><variable citdl="EntryPoint" ilk="argument" line="2442" name="cls" /><variable ilk="argument" line="2442" name="src" /><variable ilk="argument" line="2442" name="dist" /><variable citdl="cls.pattern.match()" line="2453" name="m" /><variable citdl="str" line="2455" name="msg" /><variable citdl="m.groupdict()" line="2457" name="res" /><variable citdl="cls._parse_extras()" line="2458" name="extras" /><variable line="2459" name="attrs" /></scope><scope attributes="protected __classmethod__" ilk="function" line="2462" lineend="2462" name="_parse_extras" returns="req.extras" signature="_parse_extras(extras_spec) - classmethod"><variable citdl="EntryPoint" ilk="argument" line="2462" name="cls" /><variable ilk="argument" line="2462" name="extras_spec" /><variable citdl="Requirement.parse()" line="2466" name="req" /></scope><scope attributes="__classmethod__" doc="Parse an entry point group" ilk="function" line="2471" lineend="2471" name="parse_group" returns="dict" signature="parse_group(group, lines, dist=None) - classmethod"><variable citdl="EntryPoint" ilk="argument" line="2471" name="cls" /><variable ilk="argument" line="2471" name="group" /><variable ilk="argument" line="2471" name="lines" /><variable ilk="argument" line="2471" name="dist" /><variable citdl="dict" line="2476" name="this" /><variable line="2477" name="line" /><variable citdl="parse()" line="2478" name="ep" /></scope><scope attributes="__classmethod__" doc="Parse a map of entry point groups" ilk="function" line="2484" lineend="2484" name="parse_map" returns="dict" signature="parse_map(data, dist=None) - classmethod"><variable citdl="EntryPoint" ilk="argument" line="2484" name="cls" /><variable citdl="data.items()" ilk="argument" line="2484" name="data" /><variable ilk="argument" line="2484" name="dist" /><variable citdl="dict" line="2491" name="maps" /><variable citdl="group.strip()" line="2492" name="group" /><variable line="2492" name="lines" /></scope></scope><scope attributes="protected" ilk="function" line="2504" lineend="2510" name="_remove_md5_fragment" returns="urllib.parse.urlunparse()" signature="_remove_md5_fragment(location)"><variable ilk="argument" line="2504" name="location" /><variable citdl="urllib.parse.urlparse()" line="2507" name="parsed" /></scope><scope attributes="protected" doc="Given an iterable of lines from a Metadata file, return&#10;the value of the Version field, if present, or None otherwise." ilk="function" line="2513" lineend="2522" name="_version_from_file" returns="safe_version()" signature="_version_from_file(lines)"><variable ilk="argument" line="2513" name="lines" /><variable line="2518" name="is_version_line" /><variable citdl="filter()" line="2519" name="version_lines" /><variable citdl="next()" line="2520" name="line" /><variable line="2521" name="value" /><variable attributes="protected" line="2521" name="_" /></scope><scope classrefs="object" doc="Wrap an actual or potential sys.path entry w/metadata" ilk="class" line="2525" lineend="2879" name="Distribution"><variable citdl="str" line="2527" name="PKG_INFO" /><scope attributes="__ctor__" ilk="function" line="2529" lineend="2540" name="__init__" signature="Distribution(location=None, metadata=None, project_name=None, version=None, py_version=PY_MAJOR, platform=None, precedence=EGG_DIST)"><variable citdl="Distribution" ilk="argument" line="2529" name="self" /><variable ilk="argument" line="2529" name="location" /><variable ilk="argument" line="2529" name="metadata" /><variable ilk="argument" line="2529" name="project_name" /><variable ilk="argument" line="2529" name="version" /><variable ilk="argument" line="2529" name="py_version" /><variable ilk="argument" line="2529" name="platform" /><variable citdl="int" ilk="argument" line="2529" name="precedence" /></scope><variable attributes="__instancevar__" citdl="safe_name()" line="2533" name="project_name" /><variable attributes="protected __instancevar__" citdl="safe_version()" line="2535" name="_version" /><variable attributes="__instancevar__" line="2536" name="py_version" /><variable attributes="__instancevar__" line="2537" name="platform" /><variable attributes="__instancevar__" line="2538" name="location" /><variable attributes="__instancevar__" citdl="int" line="2539" name="precedence" /><variable attributes="protected __instancevar__" citdl="EmptyProvider" line="2540" name="_provider" /><scope attributes="__classmethod__" ilk="function" line="2542" lineend="2542" name="from_location" signature="from_location(location, basename=None, **metadata) - classmethod"><variable citdl="Distribution" ilk="argument" line="2542" name="cls" /><variable ilk="argument" line="2542" name="location" /><variable ilk="argument" line="2542" name="basename" /><variable attributes="kwargs" ilk="argument" line="2542" name="metadata" /><variable line="2545" name="ext" /><variable citdl="EGG_NAME()" line="2549" name="match" /><variable line="2551" name="platform" /><variable line="2551" name="version" /><variable line="2551" name="py_version" /><variable line="2551" name="project_name" /></scope><scope attributes="protected" ilk="function" line="2559" lineend="2560" name="_reload_version" returns="Distribution" signature="_reload_version()"><variable citdl="Distribution" ilk="argument" line="2559" name="self" /></scope><variable attributes="property" citdl="tuple" line="2562" name="hashcmp" /><scope attributes="__hidden__" ilk="function" line="2562" lineend="2562" name="hashcmp (property getter)" returns="tuple" signature="hashcmp (property getter)()"><variable citdl="Distribution" ilk="argument" line="2562" name="self" /></scope><scope ilk="function" line="2573" lineend="2574" name="__hash__" returns="hash()" signature="__hash__()"><variable citdl="Distribution" ilk="argument" line="2573" name="self" /></scope><scope ilk="function" line="2576" lineend="2577" name="__lt__" returns="bool" signature="__lt__(other)"><variable citdl="Distribution" ilk="argument" line="2576" name="self" /><variable ilk="argument" line="2576" name="other" /></scope><scope ilk="function" line="2579" lineend="2580" name="__le__" returns="bool" signature="__le__(other)"><variable citdl="Distribution" ilk="argument" line="2579" name="self" /><variable ilk="argument" line="2579" name="other" /></scope><scope ilk="function" line="2582" lineend="2583" name="__gt__" returns="bool" signature="__gt__(other)"><variable citdl="Distribution" ilk="argument" line="2582" name="self" /><variable ilk="argument" line="2582" name="other" /></scope><scope ilk="function" line="2585" lineend="2586" name="__ge__" returns="bool" signature="__ge__(other)"><variable citdl="Distribution" ilk="argument" line="2585" name="self" /><variable ilk="argument" line="2585" name="other" /></scope><scope ilk="function" line="2588" lineend="2592" name="__eq__" returns="bool" signature="__eq__(other)"><variable citdl="Distribution" ilk="argument" line="2588" name="self" /><variable ilk="argument" line="2588" name="other" /></scope><scope ilk="function" line="2594" lineend="2595" name="__ne__" returns="bool" signature="__ne__(other)"><variable citdl="Distribution" ilk="argument" line="2594" name="self" /><variable ilk="argument" line="2594" name="other" /></scope><variable attributes="property" citdl="self._key" line="2601" name="key" /><scope attributes="__hidden__" ilk="function" line="2601" lineend="2601" name="key (property getter)" returns="self._key" signature="key (property getter)()"><variable citdl="Distribution" ilk="argument" line="2601" name="self" /></scope><variable attributes="protected __instancevar__" citdl="self.project_name.lower()" line="2606" name="_key" /><variable attributes="property" citdl="parse_version()" line="2609" name="parsed_version" /><scope attributes="__hidden__" ilk="function" line="2609" lineend="2609" name="parsed_version (property getter)" returns="parse_version()" signature="parsed_version (property getter)()"><variable citdl="Distribution" ilk="argument" line="2609" name="self" /></scope><variable attributes="protected __instancevar__" citdl="parse_version()" line="2612" name="_parsed_version" /><scope attributes="protected" ilk="function" line="2616" lineend="2640" name="_warn_legacy_version" signature="_warn_legacy_version()"><variable citdl="Distribution" ilk="argument" line="2616" name="self" /><variable citdl="packaging.version.LegacyVersion" line="2617" name="LV" /><variable citdl="isinstance()" line="2618" name="is_legacy" /><variable line="2631" name="tmpl" /></scope><scope attributes="__hidden__" ilk="function" line="2642" lineend="2642" name="version (property getter)" returns="_version_from_file()" signature="version (property getter)()"><variable citdl="Distribution" ilk="argument" line="2642" name="self" /><variable citdl="_version_from_file()" line="2647" name="version" /><variable citdl="str" line="2649" name="tmpl" /></scope><variable attributes="property" citdl="safe_version()" line="2642" name="version" /><variable attributes="property protected" citdl="dict" line="2653" name="_dep_map" /><scope attributes="protected __hidden__" ilk="function" line="2653" lineend="2653" name="_dep_map (property getter)" returns="self.__dep_map" signature="_dep_map (property getter)()"><variable citdl="Distribution" ilk="argument" line="2653" name="self" /><variable citdl="dict" line="2658" name="dm" /><variable line="2659" name="name" /><variable citdl="safe_extra()" line="2660" name="extra" /><variable citdl="list" line="2660" name="reqs" /><variable line="2663" name="marker" /></scope><scope doc="List of Requirements needed for this distro if `extras` are used" ilk="function" line="2673" lineend="2685" name="requires" returns="list" signature="requires(extras=())"><variable citdl="Distribution" ilk="argument" line="2673" name="self" /><variable citdl="tuple" ilk="argument" line="2673" name="extras" /><variable citdl="dict" line="2675" name="dm" /><variable citdl="list" line="2676" name="deps" /><variable line="2678" name="ext" /></scope><scope attributes="protected" ilk="function" line="2687" lineend="2690" name="_get_metadata" signature="_get_metadata(name)"><variable citdl="Distribution" ilk="argument" line="2687" name="self" /><variable ilk="argument" line="2687" name="name" /><variable line="2689" name="line" /></scope><scope doc="Ensure distribution is importable on `path` (default=sys.path)" ilk="function" line="2692" lineend="2701" name="activate" signature="activate(path=None, replace=False)"><variable citdl="Distribution" ilk="argument" line="2692" name="self" /><variable citdl="sys.path" ilk="argument" line="2692" name="path" /><variable citdl="False" ilk="argument" line="2692" name="replace" /><variable line="2699" name="pkg" /></scope><scope doc="Return what this distribution's standard .egg filename should be" ilk="function" line="2703" lineend="2712" name="egg_name" signature="egg_name()"><variable citdl="Distribution" ilk="argument" line="2703" name="self" /><variable line="2705" name="filename" /></scope><scope ilk="function" line="2714" lineend="2718" name="__repr__" returns="str()" signature="__repr__()"><variable citdl="Distribution" ilk="argument" line="2714" name="self" /></scope><scope ilk="function" line="2720" lineend="2726" name="__str__" signature="__str__()"><variable citdl="Distribution" ilk="argument" line="2720" name="self" /><variable citdl="getattr()" line="2722" name="version" /></scope><scope doc="Delegate all unrecognized public attributes to .metadata provider" ilk="function" line="2728" lineend="2732" name="__getattr__" returns="getattr()" signature="__getattr__(attr)"><variable citdl="Distribution" ilk="argument" line="2728" name="self" /><variable ilk="argument" line="2728" name="attr" /></scope><scope attributes="__classmethod__" ilk="function" line="2734" lineend="2734" name="from_filename" returns="Distribution.from_location()" signature="from_filename(filename=None, **metadata) - classmethod"><variable citdl="Distribution" ilk="argument" line="2734" name="cls" /><variable ilk="argument" line="2734" name="filename" /><variable attributes="kwargs" ilk="argument" line="2734" name="metadata" /></scope><scope doc="Return a ``Requirement`` that matches this distribution exactly" ilk="function" line="2741" lineend="2748" name="as_requirement" returns="Requirement.parse()" signature="as_requirement()"><variable citdl="Distribution" ilk="argument" line="2741" name="self" /><variable line="2744" name="spec" /></scope><scope doc="Return the `name` entry point of `group` or raise ImportError" ilk="function" line="2750" lineend="2755" name="load_entry_point" returns="ep.load()" signature="load_entry_point(group, name)"><variable citdl="Distribution" ilk="argument" line="2750" name="self" /><variable ilk="argument" line="2750" name="group" /><variable ilk="argument" line="2750" name="name" /><variable citdl="self.get_entry_info()" line="2752" name="ep" /></scope><scope doc="Return the entry point map for `group`, or the full entry map" ilk="function" line="2757" lineend="2767" name="get_entry_map" returns="ep_map.get()" signature="get_entry_map(group=None)"><variable citdl="Distribution" ilk="argument" line="2757" name="self" /><variable ilk="argument" line="2757" name="group" /><variable citdl="self._ep_map" line="2760" name="ep_map" /></scope><scope doc="Return the EntryPoint object for `group`+`name`, or ``None``" ilk="function" line="2769" lineend="2771" name="get_entry_info" signature="get_entry_info(group, name)"><variable citdl="Distribution" ilk="argument" line="2769" name="self" /><variable ilk="argument" line="2769" name="group" /><variable ilk="argument" line="2769" name="name" /></scope><scope doc="Ensure self.location is on path&#10;&#10;If replace=False (default):&#10;    - If location is already in path anywhere, do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent.&#10;      - Else: add to the end of path.&#10;If replace=True:&#10;    - If location is already on path anywhere (not eggs)&#10;      or higher priority than its parent (eggs)&#10;      do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent,&#10;        removing any lower-priority entries.&#10;      - Else: add it to the front of path." ilk="function" line="2773" lineend="2839" name="insert_on" signature="insert_on(path, loc=None, replace=False)"><variable citdl="Distribution" ilk="argument" line="2773" name="self" /><variable ilk="argument" line="2773" name="path" /><variable ilk="argument" line="2773" name="loc" /><variable citdl="False" ilk="argument" line="2773" name="replace" /><variable citdl="_normalize_cached()" line="2797" name="nloc" /><variable citdl="os.path.dirname()" line="2798" name="bdir" /><variable citdl="list" line="2799" name="npath" /><variable line="2801" name="item" /><variable citdl="npath.index()" line="2801" name="p" /><variable citdl="npath.index()" line="2831" name="np" /></scope><scope ilk="function" line="2841" lineend="2860" name="check_version_conflict" signature="check_version_conflict()"><variable citdl="Distribution" ilk="argument" line="2841" name="self" /><variable citdl="dict.fromkeys()" line="2846" name="nsp" /><variable citdl="normalize_path()" line="2847" name="loc" /><variable line="2848" name="modname" /><variable citdl="getattr()" line="2854" name="fn" /></scope><scope ilk="function" line="2863" lineend="2869" name="has_version" returns="bool" signature="has_version()"><variable citdl="Distribution" ilk="argument" line="2863" name="self" /></scope><scope doc="Copy this distribution, substituting in any changed keyword args" ilk="function" line="2871" lineend="2877" name="clone" returns="self.__class__()" signature="clone()"><variable attributes="kwargs" citdl="Distribution" ilk="argument" line="2871" name="self" /><variable citdl="str" line="2873" name="names" /><variable line="2874" name="attr" /></scope><variable attributes="property" citdl="list" line="2879" name="extras" /><scope attributes="__hidden__" ilk="function" line="2879" lineend="2879" name="extras (property getter)" returns="list" signature="extras (property getter)()"><variable citdl="Distribution" ilk="argument" line="2879" name="self" /></scope></scope><scope classrefs="Distribution" ilk="class" line="2884" lineend="2900" name="EggInfoDistribution"><scope attributes="protected" doc="Packages installed by distutils (e.g. numpy or scipy),&#10;which uses an old safe_version, and so&#10;their version numbers can get mangled when&#10;converted to filenames (e.g., 1.11.0.dev0+2329eae to&#10;1.11.0.dev0_2329eae). These distributions will not be&#10;parsed properly&#10;downstream by Distribution and safe_version, so&#10;take an extra step and try to get the version number from&#10;the metadata file itself instead of the filename." ilk="function" line="2885" lineend="2900" name="_reload_version" returns="EggInfoDistribution" signature="_reload_version()"><variable citdl="EggInfoDistribution" ilk="argument" line="2885" name="self" /><variable citdl="_version_from_file()" line="2897" name="md_version" /></scope><variable attributes="protected __instancevar__" citdl="_version_from_file()" line="2899" name="_version" /></scope><scope classrefs="Distribution" doc="Wrap an actual or potential sys.path entry&#10;w/metadata, .dist-info style." ilk="class" line="2903" lineend="2950" name="DistInfoDistribution"><variable citdl="str" line="2908" name="PKG_INFO" /><variable citdl="re.compile()" line="2909" name="EQEQ" /><scope attributes="protected __hidden__" doc="Parse and cache metadata" ilk="function" line="2911" lineend="2911" name="_parsed_pkg_info (property getter)" returns="self._pkg_info" signature="_parsed_pkg_info (property getter)()"><variable citdl="DistInfoDistribution" ilk="argument" line="2911" name="self" /><variable citdl="self.get_metadata()" line="2917" name="metadata" /></scope><variable attributes="property protected" citdl="self._pkg_info" line="2911" name="_parsed_pkg_info" /><variable attributes="protected __instancevar__" line="2918" name="_pkg_info" /><variable attributes="property protected" citdl="self._compute_dependencies()" line="2921" name="_dep_map" /><scope attributes="protected __hidden__" ilk="function" line="2921" lineend="2921" name="_dep_map (property getter)" returns="self.__dep_map" signature="_dep_map (property getter)()"><variable citdl="DistInfoDistribution" ilk="argument" line="2921" name="self" /></scope><variable attributes="private __instancevar__" citdl="self._compute_dependencies()" line="2926" name="__dep_map" /><scope attributes="protected" doc="Recompute this distribution's dependencies." ilk="function" line="2929" lineend="2950" name="_compute_dependencies" returns="dict" signature="_compute_dependencies()"><variable citdl="DistInfoDistribution" ilk="argument" line="2929" name="self" /><variable citdl="dict" line="2931" name="dm" /><variable citdl="list" line="2933" name="reqs" /><variable line="2935" name="req" /><scope ilk="function" line="2938" lineend="2941" name="reqs_for_extra" signature="reqs_for_extra(extra)"><variable ilk="argument" line="2938" name="extra" /><variable line="2939" name="req" /></scope><variable citdl="frozenset()" line="2943" name="common" /><variable line="2946" name="extra" /><variable citdl="safe_extra()" line="2947" name="s_extra" /></scope></scope><variable attributes="protected" citdl="dict" line="2953" name="_distributionImpl" /><scope ilk="function" line="2960" lineend="2970" name="issue_warning" signature="issue_warning()"><variable citdl="int" line="2961" name="level" /><variable citdl="globals()" line="2962" name="g" /></scope><scope classrefs="ValueError" ilk="class" line="2973" lineend="2975" name="RequirementParseError"><scope ilk="function" line="2974" lineend="2975" name="__str__" returns="__builtins__.str.join()" signature="__str__()"><variable citdl="RequirementParseError" ilk="argument" line="2974" name="self" /></scope></scope><scope doc="Yield ``Requirement`` objects for each specification in `strs`&#10;&#10;`strs` must be a string, or a (possibly-nested) iterable thereof." ilk="function" line="2978" lineend="2994" name="parse_requirements" signature="parse_requirements(strs)"><variable ilk="argument" line="2978" name="strs" /><variable citdl="iter()" line="2984" name="lines" /><variable line="2986" name="line" /></scope><scope classrefs="packaging.requirements.Requirement" ilk="class" line="2997" lineend="3045" name="Requirement"><scope attributes="__ctor__" doc="DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!" ilk="function" line="2998" lineend="3016" name="__init__" signature="Requirement(requirement_string)"><variable citdl="Requirement" ilk="argument" line="2998" name="self" /><variable ilk="argument" line="2998" name="requirement_string" /><variable citdl="safe_name()" line="3005" name="project_name" /></scope><variable attributes="__instancevar__" citdl="self.name" line="3004" name="unsafe_name" /><variable attributes="__instancevar__" citdl="project_name.lower()" line="3006" name="key" /><variable attributes="__instancevar__" citdl="safe_name()" line="3006" name="project_name" /><variable attributes="__instancevar__" citdl="list" line="3007" name="specs" /><variable attributes="__instancevar__" citdl="tuple()" line="3009" name="extras" /><variable attributes="__instancevar__" citdl="tuple" line="3010" name="hashCmp" /><variable attributes="private __instancevar__" citdl="hash()" line="3016" name="__hash" /><scope ilk="function" line="3018" lineend="3021" name="__eq__" returns="bool" signature="__eq__(other)"><variable citdl="Requirement" ilk="argument" line="3018" name="self" /><variable ilk="argument" line="3018" name="other" /></scope><scope ilk="function" line="3024" lineend="3025" name="__ne__" returns="bool" signature="__ne__(other)"><variable citdl="Requirement" ilk="argument" line="3024" name="self" /><variable ilk="argument" line="3024" name="other" /></scope><scope ilk="function" line="3027" lineend="3037" name="__contains__" returns="self.specifier.contains()" signature="__contains__(item)"><variable citdl="Requirement" ilk="argument" line="3027" name="self" /><variable citdl="item.version" ilk="argument" line="3027" name="item" /></scope><scope ilk="function" line="3039" lineend="3040" name="__hash__" returns="hash()" signature="__hash__()"><variable citdl="Requirement" ilk="argument" line="3039" name="self" /></scope><scope ilk="function" line="3042" lineend="3043" name="__repr__" signature="__repr__()"><variable citdl="Requirement" ilk="argument" line="3042" name="self" /></scope><scope attributes="__staticmethod__" ilk="function" line="3045" lineend="3045" name="parse" signature="parse(s) - staticmethod"><variable citdl="Requirement" ilk="argument" line="3045" name="s" /><variable line="3047" name="req" /></scope></scope><scope attributes="protected" doc="Ensure object appears in the mro even&#10;for old-style classes." ilk="function" line="3051" lineend="3058" name="_always_object" signature="_always_object(classes)"><variable ilk="argument" line="3051" name="classes" /></scope><scope attributes="protected" doc="Return an adapter factory for `ob` from `registry`" ilk="function" line="3061" lineend="3066" name="_find_adapter" signature="_find_adapter(registry, ob)"><variable ilk="argument" line="3061" name="registry" /><variable ilk="argument" line="3061" name="ob" /><variable citdl="_always_object()" line="3063" name="types" /><variable line="3064" name="t" /></scope><scope doc="Ensure that the parent directory of `path` exists" ilk="function" line="3069" lineend="3072" name="ensure_directory" signature="ensure_directory(path)"><variable ilk="argument" line="3069" name="path" /><variable citdl="os.path.dirname()" line="3071" name="dirname" /></scope><scope attributes="protected" doc="Sandbox-bypassing version of ensure_directory()" ilk="function" line="3075" lineend="3082" name="_bypass_ensure_directory" signature="_bypass_ensure_directory(path)"><variable ilk="argument" line="3075" name="path" /><variable line="3079" name="dirname" /><variable line="3079" name="filename" /></scope><scope doc="Split a string or iterable thereof into (section, content) pairs&#10;&#10;Each ``section`` is a stripped version of the section header (&quot;[section]&quot;)&#10;and each ``content`` is a list of stripped lines excluding blank lines and&#10;comment-only lines.  If there are any such lines before the first section&#10;header, they're returned in a first ``section`` of ``None``." ilk="function" line="3085" lineend="3108" name="split_sections" signature="split_sections(s)"><variable ilk="argument" line="3085" name="s" /><variable line="3093" name="section" /><variable citdl="list" line="3094" name="content" /><variable line="3095" name="line" /></scope><scope attributes="protected" ilk="function" line="3111" lineend="3119" name="_mkstemp" returns="tempfile.mkstemp()" signature="_mkstemp()"><variable citdl="os.open" line="3112" name="old_open" /></scope><scope attributes="protected" ilk="function" line="3130" lineend="3132" name="_call_aside" signature="_call_aside(**f)"><variable attributes="kwargs" ilk="argument" line="3130" name="f" /></scope><scope attributes="protected" doc="Set up global resource manager (deliberately not state-saved)" ilk="function" line="3135" lineend="3135" name="_initialize" signature="_initialize(g=globals())"><variable citdl="globals()" ilk="argument" line="3135" name="g" /><variable citdl="ResourceManager" line="3138" name="manager" /></scope><scope attributes="protected" doc="Prepare the master working set and make the ``require()``&#10;API available.&#10;&#10;This function has explicit effects on the global state&#10;of pkg_resources. It is intended to be invoked once at&#10;the initialization of this module.&#10;&#10;Invocation by other packages is unsupported and done&#10;at their own risk." ilk="function" line="3147" lineend="3147" name="_initialize_master_working_set" signature="_initialize_master_working_set()"><variable citdl="WorkingSet._build_master()" line="3160" name="working_set" /><variable citdl="working_set.require" line="3163" name="require" /><variable citdl="working_set.iter_entry_points" line="3164" name="iter_entry_points" /><variable citdl="working_set.subscribe" line="3165" name="add_activation_listener" /><variable citdl="working_set.run_script" line="3166" name="run_script" /><variable citdl="working_set.run_script" line="3168" name="run_main" /></scope></scope>