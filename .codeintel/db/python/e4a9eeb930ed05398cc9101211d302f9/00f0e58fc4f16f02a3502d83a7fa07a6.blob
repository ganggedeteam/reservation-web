<scope doc="datetime.tzinfo timezone definitions generated from the&#10;Olson timezone database:" ilk="blob" lang="Python" name="__init__" src="D:\Program Files (x86)\Python\lib\site-packages\pytz\__init__.py"><import line="11" module="sys" /><import line="12" module="datetime" /><import line="13" module="os.path" /><import line="15" module="pytz.exceptions" symbol="AmbiguousTimeError" /><import line="16" module="pytz.exceptions" symbol="InvalidTimeError" /><import line="17" module="pytz.exceptions" symbol="NonExistentTimeError" /><import line="18" module="pytz.exceptions" symbol="UnknownTimeZoneError" /><import line="19" module="pytz.lazy" symbol="LazyDict" /><import line="19" module="pytz.lazy" symbol="LazyList" /><import line="19" module="pytz.lazy" symbol="LazySet" /><import line="20" module="pytz.tzinfo" symbol="unpickler" /><import line="21" module="pytz.tzfile" symbol="build_tzinfo" /><variable citdl="str" line="25" name="OLSON_VERSION" /><variable citdl="str" line="26" name="VERSION" /><variable citdl="str" line="27" name="__version__" /><variable citdl="str" line="29" name="OLSEN_VERSION" /><variable citdl="list" line="31" name="__all__" /><variable line="47" name="str" /><scope doc="&gt;&gt;&gt; ascii('Hello')&#10;'Hello'&#10;&gt;&gt;&gt; ascii(u'Hello')&#10;'Hello'&#10;&gt;&gt;&gt; ascii(u'\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL&#10;Traceback (most recent call last):&#10;    ...&#10;UnicodeEncodeError: ..." ilk="function" line="66" lineend="77" name="ascii" returns="s.encode()" signature="ascii(s)"><variable ilk="argument" line="66" name="s" /></scope><scope doc="Open a resource from the zoneinfo subdir for reading.&#10;&#10;Uses the pkg_resources module if available and no standard file&#10;found at the calculated location.&#10;&#10;It is possible to specify different location for zoneinfo&#10;subdir by using the PYTZ_TZDATADIR environment variable." ilk="function" line="80" lineend="110" name="open_resource" returns="open_resource.resource_stream()" signature="open_resource(name)"><import line="104" module="pkg_resources" symbol="resource_stream" /><variable ilk="argument" line="80" name="name" /><variable line="89" name="name_parts" /><variable line="90" name="part" /><variable citdl="os.environ.get()" line="93" name="zoneinfo_dir" /><variable citdl="os.path.join()" line="95" name="filename" /><variable line="106" name="resource_stream" /></scope><scope doc="Return true if the given resource exists" ilk="function" line="113" lineend="119" name="resource_exists" returns="bool" signature="resource_exists(name)"><variable ilk="argument" line="113" name="name" /></scope><variable attributes="protected" citdl="dict" line="122" name="_tzinfo_cache" /><scope doc="Return a datetime.tzinfo implementation for the given timezone&#10;&#10;&gt;&gt;&gt; from datetime import datetime, timedelta&#10;&gt;&gt;&gt; utc = timezone('UTC')&#10;&gt;&gt;&gt; eastern = timezone('US/Eastern')&#10;&gt;&gt;&gt; eastern.zone&#10;'US/Eastern'&#10;&gt;&gt;&gt; timezone(str('US/Eastern')) is eastern&#10;True&#10;&gt;&gt;&gt; utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)&#10;&gt;&gt;&gt; loc_dt = utc_dt.astimezone(eastern)&#10;&gt;&gt;&gt; fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'&#10;&gt;&gt;&gt; loc_dt.strftime(fmt)&#10;'2002-10-27 0o1:0o0:0o0 EST (-0o500)'&#10;&gt;&gt;&gt; (loc_dt - timedelta(minutes=10)).strftime(fmt)&#10;'2002-10-27 0o0:50:0o0 EST (-0o500)'&#10;&gt;&gt;&gt; eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)&#10;'2002-10-27 0o1:50:0o0 EDT (-0o400)'&#10;&gt;&gt;&gt; (loc_dt + timedelta(minutes=10)).strftime(fmt)&#10;'2002-10-27 0o1:10:0o0 EST (-0o500)'&#10;&#10;Raises UnknownTimeZoneError if passed an unknown zone.&#10;&#10;&gt;&gt;&gt; try:&#10;...     timezone('Asia/Shangri-La')&#10;... except UnknownTimeZoneError:&#10;...     print('Unknown')&#10;Unknown&#10;&#10;&gt;&gt;&gt; try:&#10;...     timezone(str('\N{TRADE MARK SIGN}'))&#10;... except UnknownTimeZoneError:&#10;...     print('Unknown')&#10;Unknown" ilk="function" line="125" lineend="182" name="timezone" returns="utc" signature="timezone(zone)"><variable citdl="ascii()" ilk="argument" line="125" name="zone" /><variable citdl="open_resource()" line="174" name="fp" /></scope><scope attributes="protected" doc="Undo the time zone name munging done by older versions of pytz." ilk="function" line="185" lineend="187" name="_unmunge_zone" signature="_unmunge_zone(zone)"><variable ilk="argument" line="185" name="zone" /></scope><variable citdl="datetime.timedelta()" line="190" name="ZERO" /><variable citdl="datetime.timedelta()" line="191" name="HOUR" /><variable citdl="UTC" doc="UTC&#10;&#10;Optimized UTC implementation. It unpickles using the single module global&#10;instance defined beneath this class declaration." line="194" name="UTC" /><scope attributes="protected" doc="Factory function for utc unpickling.&#10;&#10;Makes sure that unpickling a utc instance always returns the same&#10;module global.&#10;&#10;These examples belong in the UTC class above, but it is obscured; or in&#10;the README.txt, but we are not depending on Python 2.4 so integrating&#10;the README.txt examples with the unit tests is not trivial.&#10;&#10;&gt;&gt;&gt; import datetime, pickle&#10;&gt;&gt;&gt; dt = datetime.datetime(2005, 3, 1, 14, 13, 21, tzinfo=utc)&#10;&gt;&gt;&gt; naive = dt.replace(tzinfo=None)&#10;&gt;&gt;&gt; p = pickle.dumps(dt, 1)&#10;&gt;&gt;&gt; naive_p = pickle.dumps(naive, 1)&#10;&gt;&gt;&gt; len(p) - len(naive_p)&#10;17&#10;&gt;&gt;&gt; new = pickle.loads(p)&#10;&gt;&gt;&gt; new == dt&#10;True&#10;&gt;&gt;&gt; new is dt&#10;False&#10;&gt;&gt;&gt; new.tzinfo is dt.tzinfo&#10;True&#10;&gt;&gt;&gt; utc is UTC is timezone('UTC')&#10;True&#10;&gt;&gt;&gt; utc is timezone('GMT')&#10;False" ilk="function" line="247" lineend="276" name="_UTC" returns="utc" signature="_UTC()"><variable citdl="True" line="277" name="__safe_for_unpickling__" /></scope><scope attributes="protected" doc="Factory function for unpickling pytz tzinfo instances.&#10;&#10;Just a wrapper around tzinfo.unpickler to save a few bytes in each pickle&#10;by shortening the path." ilk="function" line="280" lineend="286" name="_p" returns="unpickler()" signature="_p()"><variable citdl="True" line="287" name="__safe_for_unpickling__" /></scope><scope attributes="protected" classrefs="LazyDict" doc="Map ISO 3166 country code to a list of timezone names commonly used&#10;in that country.&#10;&#10;iso3166_code is the two letter code used to identify the country.&#10;&#10;&gt;&gt;&gt; def print_list(list_of_strings):&#10;...     'We use a helper so doctests work under Python 2.3 -&gt; 3.x'&#10;...     for s in list_of_strings:&#10;...         print(s)&#10;&#10;&gt;&gt;&gt; print_list(country_timezones['nz'])&#10;Pacific/Auckland&#10;Pacific/Chatham&#10;&gt;&gt;&gt; print_list(country_timezones['ch'])&#10;Europe/Zurich&#10;&gt;&gt;&gt; print_list(country_timezones['CH'])&#10;Europe/Zurich&#10;&gt;&gt;&gt; print_list(country_timezones[str('ch')])&#10;Europe/Zurich&#10;&gt;&gt;&gt; print_list(country_timezones['XXX'])&#10;Traceback (most recent call last):&#10;...&#10;KeyError: 'XXX'&#10;&#10;Previously, this information was exposed as a function rather than a&#10;dictionary. This is still supported::&#10;&#10;&gt;&gt;&gt; print_list(country_timezones('nz'))&#10;Pacific/Auckland&#10;Pacific/Chatham" ilk="class" line="290" lineend="343" name="_CountryTimezoneDict"><scope doc="Backwards compatibility." ilk="function" line="322" lineend="324" name="__call__" signature="__call__(iso3166_code)"><variable citdl="_CountryTimezoneDict" ilk="argument" line="322" name="self" /><variable ilk="argument" line="322" name="iso3166_code" /></scope><scope attributes="protected" ilk="function" line="326" lineend="343" name="_fill" signature="_fill()"><variable citdl="_CountryTimezoneDict" ilk="argument" line="326" name="self" /><variable citdl="dict" line="327" name="data" /><variable citdl="open_resource()" line="328" name="zone_tab" /><variable citdl="line.decode()" line="330" name="line" /></scope><variable attributes="__instancevar__" citdl="dict" line="341" name="data" /></scope><variable citdl="_CountryTimezoneDict" line="345" name="country_timezones" /><scope attributes="protected" classrefs="LazyDict" doc="Dictionary proving ISO3166 code -&gt; English name.&#10;&#10;&gt;&gt;&gt; print(country_names['au'])&#10;Australia" ilk="class" line="348" lineend="366" name="_CountryNameDict"><scope attributes="protected" ilk="function" line="354" lineend="366" name="_fill" signature="_fill()"><variable citdl="_CountryNameDict" ilk="argument" line="354" name="self" /><variable citdl="dict" line="355" name="data" /><variable citdl="open_resource()" line="356" name="zone_tab" /><variable citdl="line.decode()" line="358" name="line" /><variable line="362" name="name" /><variable line="362" name="code" /></scope><variable attributes="__instancevar__" citdl="dict" line="364" name="data" /></scope><variable citdl="_CountryNameDict" line="368" name="country_names" /><scope attributes="protected" classrefs="datetime.tzinfo" ilk="class" line="373" lineend="410" name="_FixedOffset"><variable line="375" name="zone" /><scope attributes="__ctor__" ilk="function" line="377" lineend="381" name="__init__" signature="_FixedOffset(minutes)"><variable citdl="_FixedOffset" ilk="argument" line="377" name="self" /><variable ilk="argument" line="377" name="minutes" /></scope><variable attributes="protected __instancevar__" line="380" name="_minutes" /><variable attributes="protected __instancevar__" citdl="datetime.timedelta()" line="381" name="_offset" /><scope ilk="function" line="383" lineend="384" name="utcoffset" returns="datetime.timedelta()" signature="utcoffset(dt)"><variable citdl="_FixedOffset" ilk="argument" line="383" name="self" /><variable ilk="argument" line="383" name="dt" /></scope><scope ilk="function" line="386" lineend="387" name="__reduce__" returns="tuple" signature="__reduce__()"><variable citdl="_FixedOffset" ilk="argument" line="386" name="self" /></scope><scope ilk="function" line="389" lineend="390" name="dst" returns="datetime.timedelta()" signature="dst(dt)"><variable citdl="_FixedOffset" ilk="argument" line="389" name="self" /><variable ilk="argument" line="389" name="dt" /></scope><scope ilk="function" line="392" lineend="393" name="tzname" signature="tzname(dt)"><variable citdl="_FixedOffset" ilk="argument" line="392" name="self" /><variable ilk="argument" line="392" name="dt" /></scope><scope ilk="function" line="395" lineend="396" name="__repr__" signature="__repr__()"><variable citdl="_FixedOffset" ilk="argument" line="395" name="self" /></scope><scope doc="Convert naive time to local time" ilk="function" line="398" lineend="402" name="localize" returns="dt.replace()" signature="localize(dt, is_dst=False)"><variable citdl="_FixedOffset" ilk="argument" line="398" name="self" /><variable ilk="argument" line="398" name="dt" /><variable citdl="False" ilk="argument" line="398" name="is_dst" /></scope><scope doc="Correct the timezone information on the given datetime" ilk="function" line="404" lineend="410" name="normalize" returns="dt.astimezone()" signature="normalize(dt, is_dst=False)"><variable citdl="_FixedOffset" ilk="argument" line="404" name="self" /><variable ilk="argument" line="404" name="dt" /><variable citdl="False" ilk="argument" line="404" name="is_dst" /></scope></scope><scope doc="return a fixed-offset timezone based off a number of minutes.&#10;&#10;    &gt;&gt;&gt; one = FixedOffset(-330)&#10;    &gt;&gt;&gt; one&#10;    pytz.FixedOffset(-330)&#10;    &gt;&gt;&gt; one.utcoffset(datetime.datetime.now())&#10;    datetime.timedelta(-1, 66600)&#10;    &gt;&gt;&gt; one.dst(datetime.datetime.now())&#10;    datetime.timedelta(0)&#10;&#10;    &gt;&gt;&gt; two = FixedOffset(1380)&#10;    &gt;&gt;&gt; two&#10;    pytz.FixedOffset(1380)&#10;    &gt;&gt;&gt; two.utcoffset(datetime.datetime.now())&#10;    datetime.timedelta(0, 82800)&#10;    &gt;&gt;&gt; two.dst(datetime.datetime.now())&#10;    datetime.timedelta(0)&#10;&#10;The datetime.timedelta must be between the range of -1 and 1 day,&#10;non-inclusive.&#10;&#10;    &gt;&gt;&gt; FixedOffset(1440)&#10;    Traceback (most recent call last):&#10;    ...&#10;    ValueError: ('absolute offset is too large', 1440)&#10;&#10;    &gt;&gt;&gt; FixedOffset(-1440)&#10;    Traceback (most recent call last):&#10;    ...&#10;    ValueError: ('absolute offset is too large', -1440)&#10;&#10;An offset of 0 is special-cased to return UTC.&#10;&#10;    &gt;&gt;&gt; FixedOffset(0) is UTC&#10;    True&#10;&#10;There should always be only one instance of a FixedOffset per timedelta.&#10;This should be true for multiple creation calls.&#10;&#10;    &gt;&gt;&gt; FixedOffset(-330) is one&#10;    True&#10;    &gt;&gt;&gt; FixedOffset(1380) is two&#10;    True&#10;&#10;It should also be true for pickling.&#10;&#10;    &gt;&gt;&gt; import pickle&#10;    &gt;&gt;&gt; pickle.loads(pickle.dumps(one)) is one&#10;    True&#10;    &gt;&gt;&gt; pickle.loads(pickle.dumps(two)) is two&#10;    True" ilk="function" line="413" lineend="477" name="FixedOffset" returns="class" signature="FixedOffset(offset, _tzinfos={})"><variable ilk="argument" line="413" name="offset" /><variable citdl="dict" ilk="argument" line="413" name="_tzinfos" /><variable citdl="_tzinfos.setdefault()" line="469" name="info" /><variable citdl="True" line="479" name="__safe_for_unpickling__" /></scope><scope attributes="protected" ilk="function" line="482" lineend="486" name="_test" returns="doctest.testmod()" signature="_test()"><import line="483" module="doctest" /><import line="485" module="pytz" /></scope><variable citdl="LazyList()" line="490" name="all_timezones" /><variable citdl="LazySet()" line="1085" name="all_timezones_set" /><variable citdl="LazyList()" line="1086" name="common_timezones" /><variable citdl="LazySet()" line="1529" name="common_timezones_set" /></scope>